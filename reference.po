# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-09 22:06+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr ""

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general,"
" compound statements span multiple lines, although in simple incarnations"
" a whole compound statement may be contained in one line."
msgstr ""

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements "
"implement traditional control flow constructs.  :keyword:`try` specifies "
"exception handlers and/or cleanup code for a group of statements, while "
"the :keyword:`with` statement allows the execution of initialization and "
"finalization code around a block of code.  Function and class definitions"
" are also syntactically compound statements."
msgstr ""

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause "
"consists of a header and a 'suite.'  The clause headers of a particular "
"compound statement are all at the same indentation level. Each clause "
"header begins with a uniquely identifying keyword and ends with a colon."
"  A suite is a group of statements controlled by a clause.  A suite can "
"be one or more semicolon-separated simple statements on the same line as "
"the header, following the header's colon, or it can be one or more "
"indented statements on subsequent lines.  Only the latter form of a suite"
" can contain nested compound statements; the following is illegal, mostly"
" because it wouldn't be clear to which :keyword:`if` clause a following "
":keyword:`else` clause would belong::"
msgstr ""

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this "
"context, so that in the following example, either all or none of the "
":func:`print` calls are executed::"
msgstr ""

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr ""

#: ../../reference/compound_stmts.rst:68
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin "
"with a keyword that cannot start a statement, thus there are no "
"ambiguities (the 'dangling :keyword:`else`' problem is solved in Python "
"by requiring nested :keyword:`if` statements to be indented)."
msgstr ""

#: ../../reference/compound_stmts.rst:74
msgid ""
"The formatting of the grammar rules in the following sections places each"
" clause on a separate line for clarity."
msgstr ""

#: ../../reference/compound_stmts.rst:83
msgid "The :keyword:`!if` statement"
msgstr ""

#: ../../reference/compound_stmts.rst:91
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ""

#: ../../reference/compound_stmts.rst:98
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by"
" one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if "
"present, is executed."
msgstr ""

#: ../../reference/compound_stmts.rst:108
msgid "The :keyword:`!while` statement"
msgstr ""

#: ../../reference/compound_stmts.rst:116
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as "
"an expression is true:"
msgstr ""

#: ../../reference/compound_stmts.rst:123
msgid ""
"This repeatedly tests the expression and, if it is true, executes the "
"first suite; if the expression is false (which may be the first time it "
"is tested) the suite of the :keyword:`!else` clause, if present, is "
"executed and the loop terminates."
msgstr ""

#: ../../reference/compound_stmts.rst:132
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the "
"loop without executing the :keyword:`!else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest "
"of the suite and goes back to testing the expression."
msgstr ""

#: ../../reference/compound_stmts.rst:141
msgid "The :keyword:`!for` statement"
msgstr ""

#: ../../reference/compound_stmts.rst:152
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""

#: ../../reference/compound_stmts.rst:159
msgid ""
"The expression list is evaluated once; it should yield an iterable "
"object.  An iterator is created for the result of the "
"``expression_list``.  The suite is then executed once for each item "
"provided by the iterator, in the order returned by the iterator.  Each "
"item in turn is assigned to the target list using the standard rules for "
"assignments (see :ref:`assignment`), and then the suite is executed.  "
"When the items are exhausted (which is immediately when the sequence is "
"empty or an iterator raises a :exc:`StopIteration` exception), the suite "
"in the :keyword:`!else` clause, if present, is executed, and the loop "
"terminates."
msgstr ""

#: ../../reference/compound_stmts.rst:172
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the "
"loop without executing the :keyword:`!else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest "
"of the suite and continues with the next item, or with the "
":keyword:`!else` clause if there is no next item."
msgstr ""

#: ../../reference/compound_stmts.rst:178
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those "
"made in the suite of the for-loop::"
msgstr ""

#: ../../reference/compound_stmts.rst:192
msgid ""
"Names in the target list are not deleted when the loop is finished, but "
"if the sequence is empty, they will not have been assigned to at all by "
"the loop.  Hint: the built-in function :func:`range` returns an iterator "
"of integers suitable to emulate the effect of Pascal's ``for i := a to b "
"do``; e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""

#: ../../reference/compound_stmts.rst:204
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this"
" can only occur for mutable sequences, e.g. lists).  An internal counter "
"is used to keep track of which item is used next, and this is incremented"
" on each iteration.  When this counter has reached the length of the "
"sequence the loop terminates.  This means that if the suite deletes the "
"current (or a previous) item from the sequence, the next item will be "
"skipped (since it gets the index of the current item which has already "
"been treated).  Likewise, if the suite inserts an item in the sequence "
"before the current item, the current item will be treated again the next "
"time through the loop. This can lead to nasty bugs that can be avoided by"
" making a temporary copy using a slice of the whole sequence, e.g., ::"
msgstr ""

#: ../../reference/compound_stmts.rst:225
msgid "The :keyword:`!try` statement"
msgstr ""

#: ../../reference/compound_stmts.rst:235
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""

#: ../../reference/compound_stmts.rst:248
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception "
"handler is executed. When an exception occurs in the :keyword:`!try` "
"suite, a search for an exception handler is started.  This search "
"inspects the except clauses in turn until one is found that matches the "
"exception.  An expression-less except clause, if present, must be last; "
"it matches any exception.  For an except clause with an expression, that "
"expression is evaluated, and the clause matches the exception if the "
"resulting object is \"compatible\" with the exception.  An object is "
"compatible with an exception if it is the class or a base class of the "
"exception object, or a tuple containing an item that is the class or a "
"base class of the exception object."
msgstr ""

#: ../../reference/compound_stmts.rst:260
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  "
"[#]_"
msgstr ""

#: ../../reference/compound_stmts.rst:263
msgid ""
"If the evaluation of an expression in the header of an except clause "
"raises an exception, the original search for a handler is canceled and a "
"search starts for the new exception in the surrounding code and on the "
"call stack (it is treated as if the entire :keyword:`try` statement "
"raised the exception)."
msgstr ""

#: ../../reference/compound_stmts.rst:270
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`!as` keyword in that except clause, "
"if present, and the except clause's suite is executed.  All except "
"clauses must have an executable block.  When the end of this block is "
"reached, execution continues normally after the entire try statement.  "
"(This means that if two nested handlers exist for the same exception, and"
" the exception occurs in the try clause of the inner handler, the outer "
"handler will not handle the exception.)"
msgstr ""

#: ../../reference/compound_stmts.rst:278
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at"
" the end of the except clause.  This is as if ::"
msgstr ""

#: ../../reference/compound_stmts.rst:284
msgid "was translated to ::"
msgstr ""

#: ../../reference/compound_stmts.rst:292
msgid ""
"This means the exception must be assigned to a different name to be able "
"to refer to it after the except clause.  Exceptions are cleared because "
"with the traceback attached to them, they form a reference cycle with the"
" stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""

#: ../../reference/compound_stmts.rst:301
msgid ""
"Before an except clause's suite is executed, details about the exception "
"are stored in the :mod:`sys` module and can be accessed via "
":func:`sys.exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting "
"of the exception class, the exception instance and a traceback object "
"(see section :ref:`types`) identifying the point in the program where the"
" exception occurred.  :func:`sys.exc_info` values are restored to their "
"previous values (before the call) when returning from a function that "
"handled an exception."
msgstr ""

#: ../../reference/compound_stmts.rst:315
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow "
"leaves the :keyword:`try` suite, no exception was raised, and no "
":keyword:`return`, :keyword:`continue`, or :keyword:`break` statement was"
" executed.  Exceptions in the :keyword:`!else` clause are not handled by "
"the preceding :keyword:`except` clauses."
msgstr ""

#: ../../reference/compound_stmts.rst:323
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The "
":keyword:`try` clause is executed, including any :keyword:`except` and "
":keyword:`!else` clauses.  If an exception occurs in any of the clauses "
"and is not handled, the exception is temporarily saved. The "
":keyword:`!finally` clause is executed.  If there is a saved exception it"
" is re-raised at the end of the :keyword:`!finally` clause.  If the "
":keyword:`!finally` clause raises another exception, the saved exception "
"is set as the context of the new exception. If the :keyword:`!finally` "
"clause executes a :keyword:`return`, :keyword:`break` or "
":keyword:`continue` statement, the saved exception is discarded::"
msgstr ""

#: ../../reference/compound_stmts.rst:342
msgid ""
"The exception information is not available to the program during "
"execution of the :keyword:`finally` clause."
msgstr ""

#: ../../reference/compound_stmts.rst:350
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` "
"statement is executed in the :keyword:`try` suite of a "
":keyword:`!try`...\\ :keyword:`!finally` statement, the "
":keyword:`finally` clause is also executed 'on the way out.'"
msgstr ""

#: ../../reference/compound_stmts.rst:354
msgid ""
"The return value of a function is determined by the last "
":keyword:`return` statement executed.  Since the :keyword:`finally` "
"clause always executes, a :keyword:`!return` statement executed in the "
":keyword:`!finally` clause will always be the last one executed::"
msgstr ""

#: ../../reference/compound_stmts.rst:368
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information on using the :keyword:`raise` "
"statement to generate exceptions may be found in section :ref:`raise`."
msgstr ""

#: ../../reference/compound_stmts.rst:372
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the "
":keyword:`finally` clause due to a problem with the implementation."
msgstr ""

#: ../../reference/compound_stmts.rst:381
msgid "The :keyword:`!with` statement"
msgstr ""

#: ../../reference/compound_stmts.rst:390
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block "
"with methods defined by a context manager (see section :ref:`context-"
"managers`). This allows common :keyword:`try`...\\ :keyword:`except`...\\"
" :keyword:`finally` usage patterns to be encapsulated for convenient "
"reuse."
msgstr ""

#: ../../reference/compound_stmts.rst:399
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds"
" as follows:"
msgstr ""

#: ../../reference/compound_stmts.rst:401
msgid ""
"The context expression (the expression given in the :token:`with_item`) "
"is evaluated to obtain a context manager."
msgstr ""

#: ../../reference/compound_stmts.rst:404
msgid "The context manager's :meth:`__enter__` is loaded for later use."
msgstr ""

#: ../../reference/compound_stmts.rst:406
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""

#: ../../reference/compound_stmts.rst:408
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr ""

#: ../../reference/compound_stmts.rst:410
msgid ""
"If a target was included in the :keyword:`with` statement, the return "
"value from :meth:`__enter__` is assigned to it."
msgstr ""

#: ../../reference/compound_stmts.rst:415
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target "
"list, it will be treated the same as an error occurring within the suite "
"would be. See step 6 below."
msgstr ""

#: ../../reference/compound_stmts.rst:421
msgid "The suite is executed."
msgstr ""

#: ../../reference/compound_stmts.rst:423
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an "
"exception caused the suite to be exited, its type, value, and traceback "
"are passed as arguments to :meth:`__exit__`. Otherwise, three "
":const:`None` arguments are supplied."
msgstr ""

#: ../../reference/compound_stmts.rst:428
msgid ""
"If the suite was exited due to an exception, and the return value from "
"the :meth:`__exit__` method was false, the exception is reraised.  If the"
" return value was true, the exception is suppressed, and execution "
"continues with the statement following the :keyword:`with` statement."
msgstr ""

#: ../../reference/compound_stmts.rst:433
msgid ""
"If the suite was exited for any reason other than an exception, the "
"return value from :meth:`__exit__` is ignored, and execution proceeds at "
"the normal location for the kind of exit that was taken."
msgstr ""

#: ../../reference/compound_stmts.rst:437
#: ../../reference/compound_stmts.rst:806
#: ../../reference/compound_stmts.rst:847
msgid "The following code::"
msgstr ""

#: ../../reference/compound_stmts.rst:442
#: ../../reference/compound_stmts.rst:467
#: ../../reference/compound_stmts.rst:852
msgid "is semantically equivalent to::"
msgstr ""

#: ../../reference/compound_stmts.rst:461
msgid ""
"With more than one item, the context managers are processed as if "
"multiple :keyword:`with` statements were nested::"
msgstr ""

#: ../../reference/compound_stmts.rst:473
msgid "Support for multiple context expressions."
msgstr ""

#: ../../reference/compound_stmts.rst:479 ../../reference/datamodel.rst:2560
msgid ":pep:`343` - The \"with\" statement"
msgstr ""

#: ../../reference/compound_stmts.rst:479 ../../reference/datamodel.rst:2560
msgid ""
"The specification, background, and examples for the Python "
":keyword:`with` statement."
msgstr ""

#: ../../reference/compound_stmts.rst:490
msgid "Function definitions"
msgstr ""

#: ../../reference/compound_stmts.rst:505
msgid ""
"A function definition defines a user-defined function object (see section"
" :ref:`types`):"
msgstr ""

#: ../../reference/compound_stmts.rst:525
msgid ""
"A function definition is an executable statement.  Its execution binds "
"the function name in the current local namespace to a function object (a "
"wrapper around the executable code for the function).  This function "
"object contains a reference to the current global namespace as the global"
" namespace to be used when the function is called."
msgstr ""

#: ../../reference/compound_stmts.rst:531
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""

#: ../../reference/compound_stmts.rst:537
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only"
" argument. The returned value is bound to the function name instead of "
"the function object.  Multiple decorators are applied in nested fashion. "
"For example, the following code ::"
msgstr ""

#: ../../reference/compound_stmts.rst:548
#: ../../reference/compound_stmts.rst:720
msgid "is roughly equivalent to ::"
msgstr ""

#: ../../reference/compound_stmts.rst:553
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""

#: ../../reference/compound_stmts.rst:560
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter*"
" ``=`` *expression*, the function is said to have \"default parameter "
"values.\"  For a parameter with a default value, the corresponding "
":term:`argument` may be omitted from a call, in which case the "
"parameter's default value is substituted.  If a parameter has a default "
"value, all following parameters up until the \"``*``\" must also have a "
"default value --- this is a syntactic restriction that is not expressed "
"by the grammar."
msgstr ""

#: ../../reference/compound_stmts.rst:568
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter is a mutable object, such as a list "
"or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default value is in effect modified.  This is "
"generally not what was intended.  A way around this is to use ``None`` as"
" the default, and explicitly test for it in the body of the function, "
"e.g.::"
msgstr ""

#: ../../reference/compound_stmts.rst:589
msgid ""
"Function call semantics are described in more detail in section "
":ref:`calls`. A function call always assigns values to all parameters "
"mentioned in the parameter list, either from positional arguments, from "
"keyword arguments, or from default values.  If the form "
"\"``*identifier``\" is present, it is initialized to a tuple receiving "
"any excess positional parameters, defaulting to the empty tuple. If the "
"form \"``**identifier``\" is present, it is initialized to a new ordered "
"mapping receiving any excess keyword arguments, defaulting to a new empty"
" mapping of the same type.  Parameters after \"``*``\" or "
"\"``*identifier``\" are keyword-only parameters and may only be passed by"
" keyword arguments.  Parameters before \"``/``\" are positional-only "
"parameters and may only be passed by positional arguments."
msgstr ""

#: ../../reference/compound_stmts.rst:601
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-"
"only parameters. See :pep:`570` for details."
msgstr ""

#: ../../reference/compound_stmts.rst:610
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the "
"form \"``: expression``\" following the parameter name.  Any parameter "
"may have an annotation, even those of the form ``*identifier`` or "
"``**identifier``.  Functions may have \"return\" annotation of the form "
"\"``-> expression``\" after the parameter list.  These annotations can be"
" any valid Python expression.  The presence of annotations does not "
"change the semantics of a function.  The annotation values are available "
"as values of a dictionary keyed by the parameters' names in the "
":attr:`__annotations__` attribute of the function object.  If the "
"``annotations`` import from :mod:`__future__` is used, annotations are "
"preserved as strings at runtime which enables postponed evaluation.  "
"Otherwise, they are evaluated when the function definition is executed.  "
"In this case annotations may be evaluated in a different order than they "
"appear in the source code."
msgstr ""

#: ../../reference/compound_stmts.rst:625
msgid ""
"It is also possible to create anonymous functions (functions not bound to"
" a name), for immediate use in expressions.  This uses lambda "
"expressions, described in section :ref:`lambda`.  Note that the lambda "
"expression is merely a shorthand for a simplified function definition; a "
"function defined in a \":keyword:`def`\" statement can be passed around "
"or assigned to another name just like a function defined by a lambda "
"expression.  The \":keyword:`!def`\" form is actually more powerful since"
" it allows the execution of multiple statements and annotations."
msgstr ""

#: ../../reference/compound_stmts.rst:633
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested"
" function can access the local variables of the function containing the "
"def.  See section :ref:`naming` for details."
msgstr ""

#: ../../reference/compound_stmts.rst:642
msgid ":pep:`3107` - Function Annotations"
msgstr ""

#: ../../reference/compound_stmts.rst:642
msgid "The original specification for function annotations."
msgstr ""

#: ../../reference/compound_stmts.rst:645
msgid ":pep:`484` - Type Hints"
msgstr ""

#: ../../reference/compound_stmts.rst:645
msgid "Definition of a standard meaning for annotations: type hints."
msgstr ""

#: ../../reference/compound_stmts.rst:649 ../../reference/simple_stmts.rst:362
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ""

#: ../../reference/compound_stmts.rst:648
msgid ""
"Ability to type hint variable declarations, including class variables and"
" instance variables"
msgstr ""

#: ../../reference/compound_stmts.rst:652
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ""

#: ../../reference/compound_stmts.rst:652
msgid ""
"Support for forward references within annotations by preserving "
"annotations in a string form at runtime instead of eager evaluation."
msgstr ""

#: ../../reference/compound_stmts.rst:659
msgid "Class definitions"
msgstr ""

#: ../../reference/compound_stmts.rst:674
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""

#: ../../reference/compound_stmts.rst:681
msgid ""
"A class definition is an executable statement.  The inheritance list "
"usually gives a list of base classes (see :ref:`metaclasses` for more "
"advanced uses), so each item in the list should evaluate to a class "
"object which allows subclassing.  Classes without an inheritance list "
"inherit, by default, from the base class :class:`object`; hence, ::"
msgstr ""

#: ../../reference/compound_stmts.rst:690
msgid "is equivalent to ::"
msgstr ""

#: ../../reference/compound_stmts.rst:695
msgid ""
"The class's suite is then executed in a new execution frame (see "
":ref:`naming`), using a newly created local namespace and the original "
"global namespace. (Usually, the suite contains mostly function "
"definitions.)  When the class's suite finishes execution, its execution "
"frame is discarded but its local namespace is saved. [#]_ A class object "
"is then created using the inheritance list for the base classes and the "
"saved local namespace for the attribute dictionary.  The class name is "
"bound to this class object in the original local namespace."
msgstr ""

#: ../../reference/compound_stmts.rst:704
msgid ""
"The order in which attributes are defined in the class body is preserved "
"in the new class's ``__dict__``.  Note that this is reliable only right "
"after the class is created and only for classes that were defined using "
"the definition syntax."
msgstr ""

#: ../../reference/compound_stmts.rst:709
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""

#: ../../reference/compound_stmts.rst:714
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""

#: ../../reference/compound_stmts.rst:725
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""

#: ../../reference/compound_stmts.rst:728
msgid ""
"**Programmer's note:** Variables defined in the class definition are "
"class attributes; they are shared by instances.  Instance attributes can "
"be set in a method with ``self.name = value``.  Both class and instance "
"attributes are accessible through the notation \"``self.name``\", and an "
"instance attribute hides a class attribute with the same name when "
"accessed in this way.  Class attributes can be used as defaults for "
"instance attributes, but using mutable values there can lead to "
"unexpected results.  :ref:`Descriptors <descriptors>` can be used to "
"create instance variables with different implementation details."
msgstr ""

#: ../../reference/compound_stmts.rst:743 ../../reference/datamodel.rst:2011
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ""

#: ../../reference/compound_stmts.rst:741
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are "
"constructed."
msgstr ""

#: ../../reference/compound_stmts.rst:746
msgid ":pep:`3129` - Class Decorators"
msgstr ""

#: ../../reference/compound_stmts.rst:746
msgid ""
"The proposal that added class decorators.  Function and method decorators"
" were introduced in :pep:`318`."
msgstr ""

#: ../../reference/compound_stmts.rst:753 ../../reference/datamodel.rst:2643
msgid "Coroutines"
msgstr ""

#: ../../reference/compound_stmts.rst:761
msgid "Coroutine function definition"
msgstr ""

#: ../../reference/compound_stmts.rst:771
msgid ""
"Execution of Python coroutines can be suspended and resumed at many "
"points (see :term:`coroutine`).  Inside the body of a coroutine function,"
" ``await`` and ``async`` identifiers become reserved keywords; "
":keyword:`await` expressions, :keyword:`async for` and :keyword:`async "
"with` can only be used in coroutine function bodies."
msgstr ""

#: ../../reference/compound_stmts.rst:777
msgid ""
"Functions defined with ``async def`` syntax are always coroutine "
"functions, even if they do not contain ``await`` or ``async`` keywords."
msgstr ""

#: ../../reference/compound_stmts.rst:780
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""

#: ../../reference/compound_stmts.rst:783
msgid "An example of a coroutine function::"
msgstr ""

#: ../../reference/compound_stmts.rst:794
msgid "The :keyword:`!async for` statement"
msgstr ""

#: ../../reference/compound_stmts.rst:799
msgid ""
"An :term:`asynchronous iterable` is able to call asynchronous code in its"
" *iter* implementation, and :term:`asynchronous iterator` can call "
"asynchronous code in its *next* method."
msgstr ""

#: ../../reference/compound_stmts.rst:803
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous"
" iterators."
msgstr ""

#: ../../reference/compound_stmts.rst:813
msgid "Is semantically equivalent to::"
msgstr ""

#: ../../reference/compound_stmts.rst:829
msgid "See also :meth:`__aiter__` and :meth:`__anext__` for details."
msgstr ""

#: ../../reference/compound_stmts.rst:831
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""

#: ../../reference/compound_stmts.rst:839
msgid "The :keyword:`!async with` statement"
msgstr ""

#: ../../reference/compound_stmts.rst:844
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that"
" is able to suspend execution in its *enter* and *exit* methods."
msgstr ""

#: ../../reference/compound_stmts.rst:871
msgid "See also :meth:`__aenter__` and :meth:`__aexit__` for details."
msgstr ""

#: ../../reference/compound_stmts.rst:873
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the"
" body of a coroutine function."
msgstr ""

#: ../../reference/compound_stmts.rst:879
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ""

#: ../../reference/compound_stmts.rst:879
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, "
"and added supporting syntax."
msgstr ""

#: ../../reference/compound_stmts.rst:884 ../../reference/datamodel.rst:2804
#: ../../reference/executionmodel.rst:264 ../../reference/expressions.rst:1869
#: ../../reference/import.rst:1049 ../../reference/lexical_analysis.rst:963
msgid "Footnotes"
msgstr ""

#: ../../reference/compound_stmts.rst:885
msgid ""
"The exception is propagated to the invocation stack unless there is a "
":keyword:`finally` clause which happens to raise another exception. That "
"new exception causes the old one to be lost."
msgstr ""

#: ../../reference/compound_stmts.rst:889
msgid ""
"A string literal appearing as the first statement in the function body is"
" transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""

#: ../../reference/compound_stmts.rst:893
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the "
"class's :term:`docstring`."
msgstr ""

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr ""

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr ""

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""

#: ../../reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity*"
" never changes once it has been created; you may think of it as the "
"object's address in memory.  The ':keyword:`is`' operator compares the "
"identity of two objects; the :func:`id` function returns an integer "
"representing its identity."
msgstr ""

#: ../../reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr ""

#: ../../reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports "
"(e.g., \"does it have a length?\") and also defines the possible values "
"for objects of that type.  The :func:`type` function returns an object's "
"type (which is an object itself).  Like its identity, an object's "
":dfn:`type` is also unchangeable. [#]_"
msgstr ""

#: ../../reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change "
"are said to be *mutable*; objects whose value is unchangeable once they "
"are created are called *immutable*. (The value of an immutable container "
"object that contains a reference to a mutable object can change when the "
"latter's value is changed; however the container is still considered "
"immutable, because the collection of objects it contains cannot be "
"changed.  So, immutability is not strictly the same as having an "
"unchangeable value, it is more subtle.) An object's mutability is "
"determined by its type; for instance, numbers, strings and tuples are "
"immutable, while dictionaries and lists are mutable."
msgstr ""

#: ../../reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed "
"to postpone garbage collection or omit it altogether --- it is a matter "
"of implementation quality how garbage collection is implemented, as long "
"as no objects are collected that are still reachable."
msgstr ""

#: ../../reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) "
"delayed detection of cyclically linked garbage, which collects most "
"objects as soon as they become unreachable, but is not guaranteed to "
"collect garbage containing circular references.  See the documentation of"
" the :mod:`gc` module for information on controlling the collection of "
"cyclic garbage. Other implementations act differently and CPython may "
"change. Do not depend on immediate finalization of objects when they "
"become unreachable (so you should always close files explicitly)."
msgstr ""

#: ../../reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities"
" may keep objects alive that would normally be collectable. Also note "
"that catching an exception with a ':keyword:`try`...\\ :keyword:`except`'"
" statement may keep objects alive."
msgstr ""

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open "
"files or windows.  It is understood that these resources are freed when "
"the object is garbage-collected, but since garbage collection is not "
"guaranteed to happen, such objects also provide an explicit way to "
"release the external resource, usually a :meth:`close` method. Programs "
"are strongly recommended to explicitly close such objects.  The "
"':keyword:`try`...\\ :keyword:`finally`' statement and the "
"':keyword:`with`' statement provide convenient ways to do this."
msgstr ""

#: ../../reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries."
"  The references are part of a container's value.  In most cases, when we"
" talk about the value of a container, we imply the values, not the "
"identities of the contained objects; however, when we talk about the "
"mutability of a container, only the identities of the immediately "
"contained objects are implied.  So, if an immutable container (like a "
"tuple) contains a reference to a mutable object, its value changes if "
"that mutable object is changed."
msgstr ""

#: ../../reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance "
"of object identity is affected in some sense: for immutable types, "
"operations that compute new values may actually return a reference to any"
" existing object with the same type and value, while for mutable objects "
"this is not allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may "
"or may not refer to the same object with the value one, depending on the "
"implementation, but after ``c = []; d = []``, ``c`` and ``d`` are "
"guaranteed to refer to two different, unique, newly created empty lists. "
"(Note that ``c = d = []`` assigns the same object to both ``c`` and "
"``d``.)"
msgstr ""

#: ../../reference/datamodel.rst:120
msgid "The standard type hierarchy"
msgstr ""

#: ../../reference/datamodel.rst:129
msgid ""
"Below is a list of the types that are built into Python.  Extension "
"modules (written in C, Java, or other languages, depending on the "
"implementation) can define additional types.  Future versions of Python "
"may add types to the type hierarchy (e.g., rational numbers, efficiently "
"stored arrays of integers, etc.), although such additions will often be "
"provided via the standard library instead."
msgstr ""

#: ../../reference/datamodel.rst:140
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the "
"implementation and are not intended for general use.  Their definition "
"may change in the future."
msgstr ""

#: ../../reference/datamodel.rst:150
msgid "None"
msgstr ""

#: ../../reference/datamodel.rst:147
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to"
" signify the absence of a value in many situations, e.g., it is returned "
"from functions that don't explicitly return anything. Its truth value is "
"false."
msgstr ""

#: ../../reference/datamodel.rst:165
msgid "NotImplemented"
msgstr ""

#: ../../reference/datamodel.rst:155
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods should return this value if "
"they do not implement the operation for the operands provided.  (The "
"interpreter will then try the reflected operation, or some other "
"fallback, depending on the operator.)  Its truth value is true."
msgstr ""

#: ../../reference/datamodel.rst:162
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr ""

#: ../../reference/datamodel.rst:174
msgid "Ellipsis"
msgstr ""

#: ../../reference/datamodel.rst:172
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""

#: ../../reference/datamodel.rst:261
msgid ":class:`numbers.Number`"
msgstr ""

#: ../../reference/datamodel.rst:179
msgid ""
"These are created by numeric literals and returned as results by "
"arithmetic operators and arithmetic built-in functions.  Numeric objects "
"are immutable; once created their value never changes.  Python numbers "
"are of course strongly related to mathematical numbers, but subject to "
"the limitations of numerical representation in computers."
msgstr ""

#: ../../reference/datamodel.rst:185
msgid ""
"The string representations of the numeric classes, computed by "
":meth:`__repr__` and :meth:`__str__`, have the following properties:"
msgstr ""

#: ../../reference/datamodel.rst:189
msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr ""

#: ../../reference/datamodel.rst:193
msgid "The representation is in base 10, when possible."
msgstr ""

#: ../../reference/datamodel.rst:195
msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, "
"are not shown."
msgstr ""

#: ../../reference/datamodel.rst:198
msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, "
"are not shown."
msgstr ""

#: ../../reference/datamodel.rst:201
msgid "A sign is shown only when the number is negative."
msgstr ""

#: ../../reference/datamodel.rst:203
msgid ""
"Python distinguishes between integers, floating point numbers, and "
"complex numbers:"
msgstr ""

#: ../../reference/datamodel.rst:236
msgid ":class:`numbers.Integral`"
msgstr ""

#: ../../reference/datamodel.rst:209
msgid ""
"These represent elements from the mathematical set of integers (positive "
"and negative)."
msgstr ""

#: ../../reference/datamodel.rst:212
msgid "There are two types of integers:"
msgstr ""

#: ../../reference/datamodel.rst:219
msgid "Integers (:class:`int`)"
msgstr ""

#: ../../reference/datamodel.rst:215
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in"
" a variant of 2's complement which gives the illusion of an infinite "
"string of sign bits extending to the left."
msgstr ""

#: ../../reference/datamodel.rst:231
msgid "Booleans (:class:`bool`)"
msgstr ""

#: ../../reference/datamodel.rst:227
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean "
"objects. The Boolean type is a subtype of the integer type, and Boolean "
"values behave like the values 0 and 1, respectively, in almost all "
"contexts, the exception being that when converted to a string, the "
"strings ``\"False\"`` or ``\"True\"`` are returned, respectively."
msgstr ""

#: ../../reference/datamodel.rst:235
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative"
" integers."
msgstr ""

#: ../../reference/datamodel.rst:251
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ""

#: ../../reference/datamodel.rst:245
msgid ""
"These represent machine-level double precision floating point numbers. "
"You are at the mercy of the underlying machine architecture (and C or "
"Java implementation) for the accepted range and handling of overflow. "
"Python does not support single-precision floating point numbers; the "
"savings in processor and memory usage that are usually the reason for "
"using these are dwarfed by the overhead of using objects in Python, so "
"there is no reason to complicate the language with two kinds of floating "
"point numbers."
msgstr ""

#: ../../reference/datamodel.rst:261
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ""

#: ../../reference/datamodel.rst:258
msgid ""
"These represent complex numbers as a pair of machine-level double "
"precision floating point numbers.  The same caveats apply as for floating"
" point numbers. The real and imaginary parts of a complex number ``z`` "
"can be retrieved through the read-only attributes ``z.real`` and "
"``z.imag``."
msgstr ""

#: ../../reference/datamodel.rst:378
msgid "Sequences"
msgstr ""

#: ../../reference/datamodel.rst:271
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers "
"0, 1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""

#: ../../reference/datamodel.rst:278
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index "
"*k* such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a "
"slice is a sequence of the same type.  This implies that the index set is"
" renumbered so that it starts at 0."
msgstr ""

#: ../../reference/datamodel.rst:283
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x"
" = i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""

#: ../../reference/datamodel.rst:287
msgid "Sequences are distinguished according to their mutability:"
msgstr ""

#: ../../reference/datamodel.rst:344
msgid "Immutable sequences"
msgstr ""

#: ../../reference/datamodel.rst:294
msgid ""
"An object of an immutable sequence type cannot change once it is created."
"  (If the object contains references to other objects, these other "
"objects may be mutable and may be changed; however, the collection of "
"objects directly referenced by an immutable object cannot change.)"
msgstr ""

#: ../../reference/datamodel.rst:299
msgid "The following types are immutable sequences:"
msgstr ""

#: ../../reference/datamodel.rst:322
msgid "Strings"
msgstr ""

#: ../../reference/datamodel.rst:312
msgid ""
"A string is a sequence of values that represent Unicode code points. All "
"the code points in the range ``U+0000 - U+10FFFF`` can be represented in "
"a string.  Python doesn't have a :c:type:`char` type; instead, every code"
" point in the string is represented as a string object with length ``1``."
"  The built-in function :func:`ord` converts a code point from its string"
" form to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an "
"integer in the range ``0 - 10FFFF`` to the corresponding length ``1`` "
"string object. :meth:`str.encode` can be used to convert a :class:`str` "
"to :class:`bytes` using the given text encoding, and :meth:`bytes.decode`"
" can be used to achieve the opposite."
msgstr ""

#: ../../reference/datamodel.rst:335
msgid "Tuples"
msgstr ""

#: ../../reference/datamodel.rst:330
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one"
" item (a 'singleton') can be formed by affixing a comma to an expression "
"(an expression by itself does not create a tuple, since parentheses must "
"be usable for grouping of expressions).  An empty tuple can be formed by "
"an empty pair of parentheses."
msgstr ""

#: ../../reference/datamodel.rst:344
msgid "Bytes"
msgstr ""

#: ../../reference/datamodel.rst:340
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes()` constructor can be used to "
"create bytes objects.  Also, bytes objects can be decoded to strings via "
"the :meth:`~bytes.decode` method."
msgstr ""

#: ../../reference/datamodel.rst:378
msgid "Mutable sequences"
msgstr ""

#: ../../reference/datamodel.rst:354
msgid ""
"Mutable sequences can be changed after they are created.  The "
"subscription and slicing notations can be used as the target of "
"assignment and :keyword:`del` (delete) statements."
msgstr ""

#: ../../reference/datamodel.rst:358
msgid "There are currently two intrinsic mutable sequence types:"
msgstr ""

#: ../../reference/datamodel.rst:365
msgid "Lists"
msgstr ""

#: ../../reference/datamodel.rst:363
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note "
"that there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""

#: ../../reference/datamodel.rst:373
msgid "Byte Arrays"
msgstr ""

#: ../../reference/datamodel.rst:370
msgid ""
"A bytearray object is a mutable array. They are created by the built-in "
":func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""

#: ../../reference/datamodel.rst:377
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type, as does the :mod:`collections` module."
msgstr ""

#: ../../reference/datamodel.rst:412
msgid "Set types"
msgstr ""

#: ../../reference/datamodel.rst:385
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be "
"iterated over, and the built-in function :func:`len` returns the number "
"of items in a set. Common uses for sets are fast membership testing, "
"removing duplicates from a sequence, and computing mathematical "
"operations such as intersection, union, difference, and symmetric "
"difference."
msgstr ""

#: ../../reference/datamodel.rst:392
msgid ""
"For set elements, the same immutability rules apply as for dictionary "
"keys. Note that numeric types obey the normal rules for numeric "
"comparison: if two numbers compare equal (e.g., ``1`` and ``1.0``), only "
"one of them can be contained in a set."
msgstr ""

#: ../../reference/datamodel.rst:397
msgid "There are currently two intrinsic set types:"
msgstr ""

#: ../../reference/datamodel.rst:404
msgid "Sets"
msgstr ""

#: ../../reference/datamodel.rst:402
msgid ""
"These represent a mutable set. They are created by the built-in "
":func:`set` constructor and can be modified afterwards by several "
"methods, such as :meth:`~set.add`."
msgstr ""

#: ../../reference/datamodel.rst:412
msgid "Frozen sets"
msgstr ""

#: ../../reference/datamodel.rst:409
msgid ""
"These represent an immutable set.  They are created by the built-in "
":func:`frozenset` constructor.  As a frozenset is immutable and "
":term:`hashable`, it can be used again as an element of another set, or "
"as a dictionary key."
msgstr ""

#: ../../reference/datamodel.rst:459
msgid "Mappings"
msgstr ""

#: ../../reference/datamodel.rst:420
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. "
"The subscript notation ``a[k]`` selects the item indexed by ``k`` from "
"the mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function "
":func:`len` returns the number of items in a mapping."
msgstr ""

#: ../../reference/datamodel.rst:426
msgid "There is currently a single intrinsic mapping type:"
msgstr ""

#: ../../reference/datamodel.rst:459
msgid "Dictionaries"
msgstr ""

#: ../../reference/datamodel.rst:431
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary "
"values.  The only types of values not acceptable as keys are values "
"containing lists or dictionaries or other mutable types that are compared"
" by value rather than by object identity, the reason being that the "
"efficient implementation of dictionaries requires a key's hash value to "
"remain constant. Numeric types used for keys obey the normal rules for "
"numeric comparison: if two numbers compare equal (e.g., ``1`` and "
"``1.0``) then they can be used interchangeably to index the same "
"dictionary entry."
msgstr ""

#: ../../reference/datamodel.rst:440
msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced"
" in the same order they were added sequentially over the dictionary. "
"Replacing an existing key does not change the order, however removing a "
"key and re-inserting it will add it to the end instead of keeping its old"
" place."
msgstr ""

#: ../../reference/datamodel.rst:445
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation "
"(see section :ref:`dict`)."
msgstr ""

#: ../../reference/datamodel.rst:452
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide "
"additional examples of mapping types, as does the :mod:`collections` "
"module."
msgstr ""

#: ../../reference/datamodel.rst:456
msgid ""
"Dictionaries did not preserve insertion order in versions of Python "
"before 3.6. In CPython 3.6, insertion order was preserved, but it was "
"considered an implementation detail at that time rather than a language "
"guarantee."
msgstr ""

#: ../../reference/datamodel.rst:717
msgid "Callable types"
msgstr ""

#: ../../reference/datamodel.rst:468
msgid ""
"These are the types to which the function call operation (see section "
":ref:`calls`) can be applied:"
msgstr ""

#: ../../reference/datamodel.rst:571
msgid "User-defined functions"
msgstr ""

#: ../../reference/datamodel.rst:477
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter "
"list."
msgstr ""

#: ../../reference/datamodel.rst:482
msgid "Special attributes:"
msgstr ""

#: ../../reference/datamodel.rst:500
msgid "Attribute"
msgstr ""

#: ../../reference/datamodel.rst:500 ../../reference/lexical_analysis.rst:517
#: ../../reference/lexical_analysis.rst:550
msgid "Meaning"
msgstr ""

#: ../../reference/datamodel.rst:502
msgid ":attr:`__doc__`"
msgstr ""

#: ../../reference/datamodel.rst:502
msgid ""
"The function's documentation string, or ``None`` if unavailable; not "
"inherited by subclasses."
msgstr ""

#: ../../reference/datamodel.rst:502 ../../reference/datamodel.rst:507
#: ../../reference/datamodel.rst:510 ../../reference/datamodel.rst:515
#: ../../reference/datamodel.rst:519 ../../reference/datamodel.rst:525
#: ../../reference/datamodel.rst:535 ../../reference/datamodel.rst:546
#: ../../reference/datamodel.rst:553
msgid "Writable"
msgstr ""

#: ../../reference/datamodel.rst:507
msgid ":attr:`~definition.\\ __name__`"
msgstr ""

#: ../../reference/datamodel.rst:507
msgid "The function's name."
msgstr ""

#: ../../reference/datamodel.rst:510
msgid ":attr:`~definition.\\ __qualname__`"
msgstr ""

#: ../../reference/datamodel.rst:510
msgid "The function's :term:`qualified name`."
msgstr ""

#: ../../reference/datamodel.rst:515
msgid ":attr:`__module__`"
msgstr ""

#: ../../reference/datamodel.rst:515
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""

#: ../../reference/datamodel.rst:519
msgid ":attr:`__defaults__`"
msgstr ""

#: ../../reference/datamodel.rst:519
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr ""

#: ../../reference/datamodel.rst:525
msgid ":attr:`__code__`"
msgstr ""

#: ../../reference/datamodel.rst:525
msgid "The code object representing the compiled function body."
msgstr ""

#: ../../reference/datamodel.rst:528
msgid ":attr:`__globals__`"
msgstr ""

#: ../../reference/datamodel.rst:528
msgid ""
"A reference to the dictionary that holds the function's global variables "
"--- the global namespace of the module in which the function was defined."
msgstr ""

#: ../../reference/datamodel.rst:528 ../../reference/datamodel.rst:539
msgid "Read-only"
msgstr ""

#: ../../reference/datamodel.rst:535
msgid ":attr:`~object.__dict__`"
msgstr ""

#: ../../reference/datamodel.rst:535
msgid "The namespace supporting arbitrary function attributes."
msgstr ""

#: ../../reference/datamodel.rst:539
msgid ":attr:`__closure__`"
msgstr ""

#: ../../reference/datamodel.rst:539
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's "
"free variables. See below for information on the ``cell_contents`` "
"attribute."
msgstr ""

#: ../../reference/datamodel.rst:546
msgid ":attr:`__annotations__`"
msgstr ""

#: ../../reference/datamodel.rst:546
msgid ""
"A dict containing annotations of parameters.  The keys of the dict are "
"the parameter names, and ``'return'`` for the return annotation, if "
"provided."
msgstr ""

#: ../../reference/datamodel.rst:553
msgid ":attr:`__kwdefaults__`"
msgstr ""

#: ../../reference/datamodel.rst:553
msgid "A dict containing defaults for keyword-only parameters."
msgstr ""

#: ../../reference/datamodel.rst:557
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the "
"assigned value."
msgstr ""

#: ../../reference/datamodel.rst:559
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular"
" attribute dot-notation is used to get and set such attributes. *Note "
"that the current implementation only supports function attributes on "
"user-defined functions. Function attributes on built-in functions may be "
"supported in the future.*"
msgstr ""

#: ../../reference/datamodel.rst:565
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to "
"get the value of the cell, as well as set the value."
msgstr ""

#: ../../reference/datamodel.rst:568
msgid ""
"Additional information about a function's definition can be retrieved "
"from its code object; see the description of internal types below. The "
":data:`cell <types.CellType>` type can be accessed in the :mod:`types` "
"module."
msgstr ""

#: ../../reference/datamodel.rst:634
msgid "Instance methods"
msgstr ""

#: ../../reference/datamodel.rst:579
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""

#: ../../reference/datamodel.rst:589
msgid ""
"Special read-only attributes: :attr:`__self__` is the class instance "
"object, :attr:`__func__` is the function object; :attr:`__doc__` is the "
"method's documentation (same as ``__func__.__doc__``); "
":attr:`~definition.__name__` is the method name (same as "
"``__func__.__name__``); :attr:`__module__` is the name of the module the "
"method was defined in, or ``None`` if unavailable."
msgstr ""

#: ../../reference/datamodel.rst:595
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr ""

#: ../../reference/datamodel.rst:598
msgid ""
"User-defined method objects may be created when getting an attribute of a"
" class (perhaps via an instance of that class), if that attribute is a "
"user-defined function object or a class method object."
msgstr ""

#: ../../reference/datamodel.rst:602
msgid ""
"When an instance method object is created by retrieving a user-defined "
"function object from a class via one of its instances, its "
":attr:`__self__` attribute is the instance, and the method object is said"
" to be bound.  The new method's :attr:`__func__` attribute is the "
"original function object."
msgstr ""

#: ../../reference/datamodel.rst:608
msgid ""
"When an instance method object is created by retrieving a class method "
"object from a class or instance, its :attr:`__self__` attribute is the "
"class itself, and its :attr:`__func__` attribute is the function object "
"underlying the class method."
msgstr ""

#: ../../reference/datamodel.rst:613
msgid ""
"When an instance method object is called, the underlying function "
"(:attr:`__func__`) is called, inserting the class instance "
"(:attr:`__self__`) in front of the argument list.  For instance, when "
":class:`C` is a class which contains a definition for a function "
":meth:`f`, and ``x`` is an instance of :class:`C`, calling ``x.f(1)`` is "
"equivalent to calling ``C.f(x, 1)``."
msgstr ""

#: ../../reference/datamodel.rst:620
msgid ""
"When an instance method object is derived from a class method object, the"
" \"class instance\" stored in :attr:`__self__` will actually be the class"
" itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to"
" calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""

#: ../../reference/datamodel.rst:625
msgid ""
"Note that the transformation from function object to instance method "
"object happens each time the attribute is retrieved from the instance.  "
"In some cases, a fruitful optimization is to assign the attribute to a "
"local variable and call that local variable. Also notice that this "
"transformation only happens for user-defined functions; other callable "
"objects (and all non-callable objects) are retrieved without "
"transformation.  It is also important to note that user-defined functions"
" which are attributes of a class instance are not converted to bound "
"methods; this *only* happens when the function is an attribute of the "
"class."
msgstr ""

#: ../../reference/datamodel.rst:649
msgid "Generator functions"
msgstr ""

#: ../../reference/datamodel.rst:641
msgid ""
"A function or method which uses the :keyword:`yield` statement (see "
"section :ref:`yield`) is called a :dfn:`generator function`.  Such a "
"function, when called, always returns an iterator object which can be "
"used to execute the body of the function:  calling the iterator's "
":meth:`iterator.__next__` method will cause the function to execute until"
" it provides a value using the :keyword:`!yield` statement.  When the "
"function executes a :keyword:`return` statement or falls off the end, a "
":exc:`StopIteration` exception is raised and the iterator will have "
"reached the end of the set of values to be returned."
msgstr ""

#: ../../reference/datamodel.rst:659
msgid "Coroutine functions"
msgstr ""

#: ../../reference/datamodel.rst:655
msgid ""
"A function or method which is defined using :keyword:`async def` is "
"called a :dfn:`coroutine function`.  Such a function, when called, "
"returns a :term:`coroutine` object.  It may contain :keyword:`await` "
"expressions, as well as :keyword:`async with` and :keyword:`async for` "
"statements. See also the :ref:`coroutine-objects` section."
msgstr ""

#: ../../reference/datamodel.rst:678 ../../reference/expressions.rst:617
msgid "Asynchronous generator functions"
msgstr ""

#: ../../reference/datamodel.rst:666
msgid ""
"A function or method which is defined using :keyword:`async def` and "
"which uses the :keyword:`yield` statement is called a :dfn:`asynchronous "
"generator function`.  Such a function, when called, returns an "
"asynchronous iterator object which can be used in an :keyword:`async for`"
" statement to execute the body of the function."
msgstr ""

#: ../../reference/datamodel.rst:672
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__` method "
"will return an :term:`awaitable` which when awaited will execute until it"
" provides a value using the :keyword:`yield` expression.  When the "
"function executes an empty :keyword:`return` statement or falls off the "
"end, a :exc:`StopAsyncIteration` exception is raised and the asynchronous"
" iterator will have reached the end of the set of values to be yielded."
msgstr ""

#: ../../reference/datamodel.rst:693
msgid "Built-in functions"
msgstr ""

#: ../../reference/datamodel.rst:686
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of"
" built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is "
"a standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: "
":attr:`__doc__` is the function's documentation string, or ``None`` if "
"unavailable; :attr:`~definition.__name__` is the function's name; "
":attr:`__self__` is set to ``None`` (but see the next item); "
":attr:`__module__` is the name of the module the function was defined in "
"or ``None`` if unavailable."
msgstr ""

#: ../../reference/datamodel.rst:705
msgid "Built-in methods"
msgstr ""

#: ../../reference/datamodel.rst:701
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, "
"assuming *alist* is a list object. In this case, the special read-only "
"attribute :attr:`__self__` is set to the object denoted by *alist*."
msgstr ""

#: ../../reference/datamodel.rst:712
msgid "Classes"
msgstr ""

#: ../../reference/datamodel.rst:708
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that"
" override :meth:`__new__`.  The arguments of the call are passed to "
":meth:`__new__` and, in the typical case, to :meth:`__init__` to "
"initialize the new instance."
msgstr ""

#: ../../reference/datamodel.rst:717
msgid "Class Instances"
msgstr ""

#: ../../reference/datamodel.rst:715
msgid ""
"Instances of arbitrary classes can be made callable by defining a "
":meth:`__call__` method in their class."
msgstr ""

#: ../../reference/datamodel.rst:767
msgid "Modules"
msgstr ""

#: ../../reference/datamodel.rst:724
msgid ""
"Modules are a basic organizational unit of Python code, and are created "
"by the :ref:`import system <importsystem>` as invoked either by the "
":keyword:`import` statement, or by calling functions such as "
":func:`importlib.import_module` and built-in :func:`__import__`.  A "
"module object has a namespace implemented by a dictionary object (this is"
" the dictionary referenced by the ``__globals__`` attribute of functions "
"defined in the module).  Attribute references are translated to lookups "
"in this dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``."
" A module object does not contain the code object used to initialize the "
"module (since it isn't needed once the initialization is done)."
msgstr ""

#: ../../reference/datamodel.rst:736
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., "
"``m.x = 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""

#: ../../reference/datamodel.rst:746
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; "
":attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__annotations__` (optional) is a dictionary "
"containing :term:`variable annotations <variable annotation>` collected "
"during module body execution; :attr:`__file__` is the pathname of the "
"file from which the module was loaded, if it was loaded from a file. The "
":attr:`__file__` attribute may be missing for certain types of modules, "
"such as C modules that are statically linked into the interpreter; for "
"extension modules loaded dynamically from a shared library, it is the "
"pathname of the shared library file."
msgstr ""

#: ../../reference/datamodel.rst:759
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr ""

#: ../../reference/datamodel.rst:764
msgid ""
"Because of the way CPython clears module dictionaries, the module "
"dictionary will be cleared when the module falls out of scope even if the"
" dictionary still has live references.  To avoid this, copy the "
"dictionary or keep the module around while using its dictionary directly."
msgstr ""

#: ../../reference/datamodel.rst:826
msgid "Custom classes"
msgstr ""

#: ../../reference/datamodel.rst:770
msgid ""
"Custom class types are typically created by class definitions (see "
"section :ref:`class`).  A class has a namespace implemented by a "
"dictionary object. Class attribute references are translated to lookups "
"in this dictionary, e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` "
"(although there are a number of hooks which allow for other means of "
"locating attributes). When the attribute name is not found there, the "
"attribute search continues in the base classes. This search of the base "
"classes uses the C3 method resolution order which behaves correctly even "
"in the presence of 'diamond' inheritance structures where there are "
"multiple inheritance paths leading back to a common ancestor. Additional "
"details on the C3 MRO used by Python can be found in the documentation "
"accompanying the 2.3 release at "
"https://www.python.org/download/releases/2.3/mro/."
msgstr ""

#: ../../reference/datamodel.rst:794
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield "
"a class method object, it is transformed into an instance method object "
"whose :attr:`__self__` attribute is :class:`C`.  When it would yield a "
"static method object, it is transformed into the object wrapped by the "
"static method object. See section :ref:`descriptors` for another way in "
"which attributes retrieved from a class may differ from those actually "
"contained in its :attr:`~object.__dict__`."
msgstr ""

#: ../../reference/datamodel.rst:804
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""

#: ../../reference/datamodel.rst:809
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""

#: ../../reference/datamodel.rst:819
msgid ""
"Special attributes: :attr:`~definition.__name__` is the class name; "
":attr:`__module__` is the module name in which the class was defined; "
":attr:`~object.__dict__` is the dictionary containing the class's "
"namespace; :attr:`~class.__bases__` is a tuple containing the base "
"classes, in the order of their occurrence in the base class list; "
":attr:`__doc__` is the class's documentation string, or ``None`` if "
"undefined; :attr:`__annotations__` (optional) is a dictionary containing "
":term:`variable annotations <variable annotation>` collected during class"
" body execution."
msgstr ""

#: ../../reference/datamodel.rst:869
msgid "Class instances"
msgstr ""

#: ../../reference/datamodel.rst:835
msgid ""
"A class instance is created by calling a class object (see above).  A "
"class instance has a namespace implemented as a dictionary which is the "
"first place in which attribute references are searched.  When an "
"attribute is not found there, and the instance's class has an attribute "
"by that name, the search continues with the class attributes.  If a class"
" attribute is found that is a user-defined function object, it is "
"transformed into an instance method object whose :attr:`__self__` "
"attribute is the instance.  Static method and class method objects are "
"also transformed; see above under \"Classes\".  See section "
":ref:`descriptors` for another way in which attributes of a class "
"retrieved via its instances may differ from the objects actually stored "
"in the class's :attr:`~object.__dict__`.  If no class attribute is found,"
" and the object's class has a :meth:`__getattr__` method, that is called "
"to satisfy the lookup."
msgstr ""

#: ../../reference/datamodel.rst:851
msgid ""
"Attribute assignments and deletions update the instance's dictionary, "
"never a class's dictionary.  If the class has a :meth:`__setattr__` or "
":meth:`__delattr__` method, this is called instead of updating the "
"instance dictionary directly."
msgstr ""

#: ../../reference/datamodel.rst:861
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they"
" have methods with certain special names.  See section "
":ref:`specialnames`."
msgstr ""

#: ../../reference/datamodel.rst:868
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary;"
" :attr:`~instance.__class__` is the instance's class."
msgstr ""

#: ../../reference/datamodel.rst:895
msgid "I/O objects (also known as file objects)"
msgstr ""

#: ../../reference/datamodel.rst:885
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and"
" also :func:`os.popen`, :func:`os.fdopen`, and the "
":meth:`~socket.socket.makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules)."
msgstr ""

#: ../../reference/datamodel.rst:891
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are "
"initialized to file objects corresponding to the interpreter's standard "
"input, output and error streams; they are all open in text mode and "
"therefore follow the interface defined by the :class:`io.TextIOBase` "
"abstract class."
msgstr ""

#: ../../reference/datamodel.rst:1146
msgid "Internal types"
msgstr ""

#: ../../reference/datamodel.rst:902
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but"
" they are mentioned here for completeness."
msgstr ""

#: ../../reference/datamodel.rst:977
msgid "Code objects"
msgstr ""

#: ../../reference/datamodel.rst:909
msgid ""
"Code objects represent *byte-compiled* executable Python code, or "
":term:`bytecode`. The difference between a code object and a function "
"object is that the function object contains an explicit reference to the "
"function's globals (the module in which it was defined), while a code "
"object contains no context; also the default argument values are stored "
"in the function object, not in the code object (because they represent "
"values calculated at run-time).  Unlike function objects, code objects "
"are immutable and contain no references (directly or indirectly) to "
"mutable objects."
msgstr ""

#: ../../reference/datamodel.rst:936
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; "
":attr:`co_argcount` is the total number of positional arguments "
"(including positional-only arguments and arguments with default values); "
":attr:`co_posonlyargcount` is the number of positional-only arguments "
"(including arguments with default values); :attr:`co_kwonlyargcount` is "
"the number of keyword-only arguments (including arguments with default "
"values); :attr:`co_nlocals` is the number of local variables used by the "
"function (including arguments); :attr:`co_varnames` is a tuple containing"
" the names of the local variables (starting with the argument names); "
":attr:`co_cellvars` is a tuple containing the names of local variables "
"that are referenced by nested functions; :attr:`co_freevars` is a tuple "
"containing the names of free variables; :attr:`co_code` is a string "
"representing the sequence of bytecode instructions; :attr:`co_consts` is "
"a tuple containing the literals used by the bytecode; :attr:`co_names` is"
" a tuple containing the names used by the bytecode; :attr:`co_filename` "
"is the filename from which the code was compiled; :attr:`co_firstlineno` "
"is the first line number of the function; :attr:`co_lnotab` is a string "
"encoding the mapping from bytecode offsets to line numbers (for details "
"see the source code of the interpreter); :attr:`co_stacksize` is the "
"required stack size; :attr:`co_flags` is an integer encoding a number of "
"flags for the interpreter."
msgstr ""

#: ../../reference/datamodel.rst:960
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is"
" set if the function uses the ``*arguments`` syntax to accept an "
"arbitrary number of positional arguments; bit ``0x08`` is set if the "
"function uses the ``**keywords`` syntax to accept arbitrary keyword "
"arguments; bit ``0x20`` is set if the function is a generator."
msgstr ""

#: ../../reference/datamodel.rst:966
msgid ""
"Future feature declarations (``from __future__ import division``) also "
"use bits in :attr:`co_flags` to indicate whether a code object was "
"compiled with a particular feature enabled: bit ``0x2000`` is set if the "
"function was compiled with future division enabled; bits ``0x10`` and "
"``0x1000`` were used in earlier versions of Python."
msgstr ""

#: ../../reference/datamodel.rst:972
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ""

#: ../../reference/datamodel.rst:976
msgid ""
"If a code object represents a function, the first item in "
":attr:`co_consts` is the documentation string of the function, or "
"``None`` if undefined."
msgstr ""

#: ../../reference/datamodel.rst:1039
msgid "Frame objects"
msgstr ""

#: ../../reference/datamodel.rst:984
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below), and are also passed to registered trace functions."
msgstr ""

#: ../../reference/datamodel.rst:995
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack "
"frame (towards the caller), or ``None`` if this is the bottom stack "
"frame; :attr:`f_code` is the code object being executed in this frame; "
":attr:`f_locals` is the dictionary used to look up local variables; "
":attr:`f_globals` is used for global variables; :attr:`f_builtins` is "
"used for built-in (intrinsic) names; :attr:`f_lasti` gives the precise "
"instruction (this is an index into the bytecode string of the code "
"object)."
msgstr ""

#: ../../reference/datamodel.rst:1003
msgid ""
"Accessing ``f_code`` raises an :ref:`auditing event <auditing>` "
"``object.__getattr__`` with arguments ``obj`` and ``\"f_code\"``."
msgstr ""

#: ../../reference/datamodel.rst:1012
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a "
"function called for various events during code execution (this is used by"
" the debugger). Normally an event is triggered for each new source line -"
" this can be disabled by setting :attr:`f_trace_lines` to :const:`False`."
msgstr ""

#: ../../reference/datamodel.rst:1017
msgid ""
"Implementations *may* allow per-opcode events to be requested by setting "
":attr:`f_trace_opcodes` to :const:`True`. Note that this may lead to "
"undefined interpreter behaviour if exceptions raised by the trace "
"function escape to the function being traced."
msgstr ""

#: ../../reference/datamodel.rst:1022
msgid ""
":attr:`f_lineno` is the current line number of the frame --- writing to "
"this from within a trace function jumps to the given line (only for the "
"bottom-most frame).  A debugger can implement a Jump command (aka Set "
"Next Statement) by writing to f_lineno."
msgstr ""

#: ../../reference/datamodel.rst:1027
msgid "Frame objects support one method:"
msgstr ""

#: ../../reference/datamodel.rst:1031
msgid ""
"This method clears all references to local variables held by the frame.  "
"Also, if the frame belonged to a generator, the generator is finalized.  "
"This helps break reference cycles involving frame objects (for example "
"when catching an exception and storing its traceback for later use)."
msgstr ""

#: ../../reference/datamodel.rst:1037
msgid ":exc:`RuntimeError` is raised if the frame is currently executing."
msgstr ""

#: ../../reference/datamodel.rst:1102
msgid "Traceback objects"
msgstr ""

#: ../../reference/datamodel.rst:1054
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is implicitly created when an exception occurs, and may also be "
"explicitly created by calling :class:`types.TracebackType`."
msgstr ""

#: ../../reference/datamodel.rst:1058
msgid ""
"For implicitly created tracebacks, when the search for an exception "
"handler unwinds the execution stack, at each unwound level a traceback "
"object is inserted in front of the current traceback.  When an exception "
"handler is entered, the stack trace is made available to the program. "
"(See section :ref:`try`.) It is accessible as the third item of the tuple"
" returned by ``sys.exc_info()``, and as the ``__traceback__`` attribute "
"of the caught exception."
msgstr ""

#: ../../reference/datamodel.rst:1066
msgid ""
"When the program contains no suitable handler, the stack trace is written"
" (nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as "
"``sys.last_traceback``."
msgstr ""

#: ../../reference/datamodel.rst:1071
msgid ""
"For explicitly created tracebacks, it is up to the creator of the "
"traceback to determine how the ``tb_next`` attributes should be linked to"
" form a full stack trace."
msgstr ""

#: ../../reference/datamodel.rst:1081
msgid ""
"Special read-only attributes: :attr:`tb_frame` points to the execution "
"frame of the current level; :attr:`tb_lineno` gives the line number where"
" the exception occurred; :attr:`tb_lasti` indicates the precise "
"instruction. The line number and last instruction in the traceback may "
"differ from the line number of its frame object if the exception occurred"
" in a :keyword:`try` statement with no matching except clause or with a "
"finally clause."
msgstr ""

#: ../../reference/datamodel.rst:1090
msgid ""
"Accessing ``tb_frame`` raises an :ref:`auditing event <auditing>` "
"``object.__getattr__`` with arguments ``obj`` and ``\"tb_frame\"``."
msgstr ""

#: ../../reference/datamodel.rst:1096
msgid ""
"Special writable attribute: :attr:`tb_next` is the next level in the "
"stack trace (towards the frame where the exception occurred), or ``None``"
" if there is no next level."
msgstr ""

#: ../../reference/datamodel.rst:1100
msgid ""
"Traceback objects can now be explicitly instantiated from Python code, "
"and the ``tb_next`` attribute of existing instances can be updated."
msgstr ""

#: ../../reference/datamodel.rst:1128
msgid "Slice objects"
msgstr ""

#: ../../reference/datamodel.rst:1107
msgid ""
"Slice objects are used to represent slices for :meth:`__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""

#: ../../reference/datamodel.rst:1115
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; "
":attr:`~slice.stop` is the upper bound; :attr:`~slice.step` is the step "
"value; each is ``None`` if omitted.  These attributes can have any type."
msgstr ""

#: ../../reference/datamodel.rst:1119
msgid "Slice objects support one method:"
msgstr ""

#: ../../reference/datamodel.rst:1123
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if "
"applied to a sequence of *length* items.  It returns a tuple of three "
"integers; respectively these are the *start* and *stop* indices and the "
"*step* or stride length of the slice. Missing or out-of-bounds indices "
"are handled in a manner consistent with regular slices."
msgstr ""

#: ../../reference/datamodel.rst:1138
msgid "Static method objects"
msgstr ""

#: ../../reference/datamodel.rst:1131
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method "
"object is a wrapper around any other object, usually a user-defined "
"method object. When a static method object is retrieved from a class or a"
" class instance, the object actually returned is the wrapped object, "
"which is not subject to any further transformation. Static method objects"
" are not themselves callable, although the objects they wrap usually are."
" Static method objects are created by the built-in :func:`staticmethod` "
"constructor."
msgstr ""

#: ../../reference/datamodel.rst:1146
msgid "Class method objects"
msgstr ""

#: ../../reference/datamodel.rst:1141
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from"
" classes and class instances. The behaviour of class method objects upon "
"such retrieval is described above, under \"User-defined methods\". Class "
"method objects are created by the built-in :func:`classmethod` "
"constructor."
msgstr ""

#: ../../reference/datamodel.rst:1151
msgid "Special method names"
msgstr ""

#: ../../reference/datamodel.rst:1157
msgid ""
"A class can implement certain operations that are invoked by special "
"syntax (such as arithmetic operations or subscripting and slicing) by "
"defining methods with special names. This is Python's approach to "
":dfn:`operator overloading`, allowing classes to define their own "
"behavior with respect to language operators.  For instance, if a class "
"defines a method named :meth:`__getitem__`, and ``x`` is an instance of "
"this class, then ``x[i]`` is roughly equivalent to "
"``type(x).__getitem__(x, i)``.  Except where mentioned, attempts to "
"execute an operation raise an exception when no appropriate method is "
"defined (typically :exc:`AttributeError` or :exc:`TypeError`)."
msgstr ""

#: ../../reference/datamodel.rst:1167
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets "
":meth:`__iter__` to ``None``, the class is not iterable, so calling "
":func:`iter` on its instances will raise a :exc:`TypeError` (without "
"falling back to :meth:`__getitem__`). [#]_"
msgstr ""

#: ../../reference/datamodel.rst:1173
msgid ""
"When implementing a class that emulates any built-in type, it is "
"important that the emulation only be implemented to the degree that it "
"makes sense for the object being modelled.  For example, some sequences "
"may work well with retrieval of individual elements, but extracting a "
"slice may not make sense.  (One example of this is the "
":class:`~xml.dom.NodeList` interface in the W3C's Document Object Model.)"
msgstr ""

#: ../../reference/datamodel.rst:1184
msgid "Basic customization"
msgstr ""

#: ../../reference/datamodel.rst:1190
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a "
"static method (special-cased so you need not declare it as such) that "
"takes the class of which an instance was requested as its first argument."
"  The remaining arguments are those passed to the object constructor "
"expression (the call to the class).  The return value of :meth:`__new__` "
"should be the new object instance (usually an instance of *cls*)."
msgstr ""

#: ../../reference/datamodel.rst:1197
msgid ""
"Typical implementations create a new instance of the class by invoking "
"the superclass's :meth:`__new__` method using ``super().__new__(cls[, "
"...])`` with appropriate arguments and then modifying the newly-created "
"instance as necessary before returning it."
msgstr ""

#: ../../reference/datamodel.rst:1202
msgid ""
"If :meth:`__new__` is invoked during object construction and it returns "
"an instance of *cls*, then the new instances :meth:`__init__` method "
"will be invoked like ``__init__(self[, ...])``, where *self* is the new "
"instance and the remaining arguments are the same as were passed to the "
"object constructor."
msgstr ""

#: ../../reference/datamodel.rst:1207
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""

#: ../../reference/datamodel.rst:1210
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types"
" (like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""

#: ../../reference/datamodel.rst:1219
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but "
"before it is returned to the caller.  The arguments are those passed to "
"the class constructor expression.  If a base class has an "
":meth:`__init__` method, the derived class's :meth:`__init__` method, if "
"any, must explicitly call it to ensure proper initialization of the base "
"class part of the instance; for example: ``super().__init__([args...])``."
msgstr ""

#: ../../reference/datamodel.rst:1226
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in "
"constructing objects (:meth:`__new__` to create it, and :meth:`__init__` "
"to customize it), no non-``None`` value may be returned by "
":meth:`__init__`; doing so will cause a :exc:`TypeError` to be raised at "
"runtime."
msgstr ""

#: ../../reference/datamodel.rst:1239
msgid ""
"Called when the instance is about to be destroyed.  This is also called a"
" finalizer or (improperly) a destructor.  If a base class has a "
":meth:`__del__` method, the derived class's :meth:`__del__` method, if "
"any, must explicitly call it to ensure proper deletion of the base class "
"part of the instance."
msgstr ""

#: ../../reference/datamodel.rst:1245
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method "
"to postpone destruction of the instance by creating a new reference to "
"it.  This is called object *resurrection*.  It is implementation-"
"dependent whether :meth:`__del__` is called a second time when a "
"resurrected object is about to be destroyed; the current :term:`CPython` "
"implementation only calls it once."
msgstr ""

#: ../../reference/datamodel.rst:1252
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits."
msgstr ""

#: ../../reference/datamodel.rst:1257
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements"
" the reference count for ``x`` by one, and the latter is only called when"
" ``x``'s reference count reaches zero."
msgstr ""

#: ../../reference/datamodel.rst:1272
msgid "Documentation for the :mod:`gc` module."
msgstr ""

#: ../../reference/datamodel.rst:1276
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods "
"are invoked, exceptions that occur during their execution are ignored, "
"and a warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""

#: ../../reference/datamodel.rst:1280
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the "
"resource may already be taken by the code that gets interrupted to "
"execute :meth:`__del__`."
msgstr ""

#: ../../reference/datamodel.rst:1286
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python "
"guarantees that globals whose name begins with a single underscore are "
"deleted from their module before other globals are deleted; if no other "
"references to such globals exist, this may help in assuring that imported"
" modules are still available at the time when the :meth:`__del__` method "
"is called."
msgstr ""

#: ../../reference/datamodel.rst:1301
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look"
" like a valid Python expression that could be used to recreate an object "
"with the same value (given an appropriate environment).  If this is not "
"possible, a string of the form ``<...some useful description...>`` should"
" be returned. The return value must be a string object. If a class "
"defines :meth:`__repr__` but not :meth:`__str__`, then :meth:`__repr__` "
"is also used when an \"informal\" string representation of instances of "
"that class is required."
msgstr ""

#: ../../reference/datamodel.rst:1310
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr ""

#: ../../reference/datamodel.rst:1321
msgid ""
"Called by :func:`str(object) <str>` and the built-in functions "
":func:`format` and :func:`print` to compute the \"informal\" or nicely "
"printable string representation of an object.  The return value must be a"
" :ref:`string <textseq>` object."
msgstr ""

#: ../../reference/datamodel.rst:1326
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more"
" convenient or concise representation can be used."
msgstr ""

#: ../../reference/datamodel.rst:1330
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""

#: ../../reference/datamodel.rst:1340
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string "
"representation of an object. This should return a :class:`bytes` object."
msgstr ""

#: ../../reference/datamodel.rst:1351
msgid ""
"Called by the :func:`format` built-in function, and by extension, "
"evaluation of :ref:`formatted string literals <f-strings>` and the "
":meth:`str.format` method, to produce a \"formatted\" string "
"representation of an object. The *format_spec* argument is a string that "
"contains a description of the formatting options desired. The "
"interpretation of the *format_spec* argument is up to the type "
"implementing :meth:`__format__`, however most classes will either "
"delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""

#: ../../reference/datamodel.rst:1361
msgid "See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""

#: ../../reference/datamodel.rst:1363
msgid "The return value must be a string object."
msgstr ""

#: ../../reference/datamodel.rst:1365
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""

#: ../../reference/datamodel.rst:1369
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(self), '')``."
msgstr ""

#: ../../reference/datamodel.rst:1385
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls "
"``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls "
"``x.__eq__(y)``, ``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls "
"``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""

#: ../../reference/datamodel.rst:1391
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if "
"it does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful "
"comparison. However, these methods can return any value, so if the "
"comparison operator is used in a Boolean context (e.g., in the condition "
"of an ``if`` statement), Python will call :func:`bool` on the value to "
"determine if the result is true or false."
msgstr ""

#: ../../reference/datamodel.rst:1398
msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, "
"returning ``NotImplemented`` in the case of a false comparison: ``True if"
" x is y else NotImplemented``. For :meth:`__ne__`, by default it "
"delegates to :meth:`__eq__` and inverts the result unless it is "
"``NotImplemented``.  There are no other implied relationships among the "
"comparison operators or default implementations; for example, the truth "
"of ``(x<y or x==y)`` does not imply ``x<=y``. To automatically generate "
"ordering operations from a single root operation, see "
":func:`functools.total_ordering`."
msgstr ""

#: ../../reference/datamodel.rst:1407
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on "
"creating :term:`hashable` objects which support custom comparison "
"operations and are usable as dictionary keys."
msgstr ""

#: ../../reference/datamodel.rst:1411
msgid ""
"There are no swapped-argument versions of these methods (to be used when "
"the left argument does not support the operation but the right argument "
"does); rather, :meth:`__lt__` and :meth:`__gt__` are each other's "
"reflection, :meth:`__le__` and :meth:`__ge__` are each other's "
"reflection, and :meth:`__eq__` and :meth:`__ne__` are their own "
"reflection. If the operands are of different types, and right operand's "
"type is a direct or indirect subclass of the left operand's type, the "
"reflected method of the right operand has priority, otherwise the left "
"operand's method has priority.  Virtual subclassing is not considered."
msgstr ""

#: ../../reference/datamodel.rst:1428
msgid ""
"Called by built-in function :func:`hash` and for operations on members of"
" hashed collections including :class:`set`, :class:`frozenset`, and "
":class:`dict`.  :meth:`__hash__` should return an integer. The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of"
" the object that also play a part in comparison of objects by packing "
"them into a tuple and hashing the tuple. Example::"
msgstr ""

#: ../../reference/datamodel.rst:1441
msgid ""
":func:`hash` truncates the value returned from an object's custom "
":meth:`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is "
"typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an "
"object's   :meth:`__hash__` must interoperate on builds of different bit "
"sizes, be sure to check the width on all supported builds.  An easy way "
"to do this is with ``python -c \"import sys; "
"print(sys.hash_info.width)\"``."
msgstr ""

#: ../../reference/datamodel.rst:1449
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define "
"a :meth:`__hash__` operation either; if it defines :meth:`__eq__` but not"
" :meth:`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an "
":meth:`__eq__` method, it should not implement :meth:`__hash__`, since "
"the implementation of hashable collections requires that a key's hash "
"value is immutable (if the object's hash value changes, it will be in the"
" wrong hash bucket)."
msgstr ""

#: ../../reference/datamodel.rst:1458
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) "
"and ``x.__hash__()`` returns an appropriate value such that ``x == y`` "
"implies both that ``x is y`` and ``hash(x) == hash(y)``."
msgstr ""

#: ../../reference/datamodel.rst:1463
msgid ""
"A class that overrides :meth:`__eq__` and does not define "
":meth:`__hash__` will have its :meth:`__hash__` implicitly set to "
"``None``.  When the :meth:`__hash__` method of a class is ``None``, "
"instances of the class will raise an appropriate :exc:`TypeError` when a "
"program attempts to retrieve their hash value, and will also be correctly"
" identified as unhashable when checking ``isinstance(obj, "
"collections.abc.Hashable)``."
msgstr ""

#: ../../reference/datamodel.rst:1470
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the "
"implementation of :meth:`__hash__` from a parent class, the interpreter "
"must be told this explicitly by setting ``__hash__ = "
"<ParentClass>.__hash__``."
msgstr ""

#: ../../reference/datamodel.rst:1474
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A"
" class which defines its own :meth:`__hash__` that explicitly raises a "
":exc:`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""

#: ../../reference/datamodel.rst:1483
msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""

#: ../../reference/datamodel.rst:1488
msgid ""
"This is intended to provide protection against a denial-of-service caused"
" by carefully-chosen inputs that exploit the worst case performance of a "
"dict insertion, O(n^2) complexity.  See "
"http://www.ocert.org/advisories/ocert-2011-003.html for details."
msgstr ""

#: ../../reference/datamodel.rst:1493
msgid ""
"Changing hash values affects the iteration order of sets. Python has "
"never made guarantees about this ordering (and it typically varies "
"between 32-bit and 64-bit builds)."
msgstr ""

#: ../../reference/datamodel.rst:1497
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr ""

#: ../../reference/datamodel.rst:1499
msgid "Hash randomization is enabled by default."
msgstr ""

#: ../../reference/datamodel.rst:1507
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not"
" defined, :meth:`__len__` is called, if it is defined, and the object is "
"considered true if its result is nonzero.  If a class defines neither "
":meth:`__len__` nor :meth:`__bool__`, all its instances are considered "
"true."
msgstr ""

#: ../../reference/datamodel.rst:1518
msgid "Customizing attribute access"
msgstr ""

#: ../../reference/datamodel.rst:1520
msgid ""
"The following methods can be defined to customize the meaning of "
"attribute access (use of, assignment to, or deletion of ``x.name``) for "
"class instances."
msgstr ""

#: ../../reference/datamodel.rst:1528
msgid ""
"Called when the default attribute access fails with an "
":exc:`AttributeError` (either :meth:`__getattribute__` raises an "
":exc:`AttributeError` because *name* is not an instance attribute or an "
"attribute in the class tree for ``self``; or :meth:`__get__` of a *name* "
"property raises :exc:`AttributeError`).  This method should either return"
" the (computed) attribute value or raise an :exc:`AttributeError` "
"exception."
msgstr ""

#: ../../reference/datamodel.rst:1535
msgid ""
"Note that if the attribute is found through the normal mechanism, "
":meth:`__getattr__` is not called.  (This is an intentional asymmetry "
"between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both "
"for efficiency reasons and because otherwise :meth:`__getattr__` would "
"have no way to access other attributes of the instance.  Note that at "
"least for instance variables, you can fake total control by not inserting"
" any values in the instance attribute dictionary (but instead inserting "
"them in another object).  See the :meth:`__getattribute__` method below "
"for a way to actually get total control over attribute access."
msgstr ""

#: ../../reference/datamodel.rst:1548
msgid ""
"Called unconditionally to implement attribute accesses for instances of "
"the class. If the class also defines :meth:`__getattr__`, the latter will"
" not be called unless :meth:`__getattribute__` either calls it explicitly"
" or raises an :exc:`AttributeError`. This method should return the "
"(computed) attribute value or raise an :exc:`AttributeError` exception. "
"In order to avoid infinite recursion in this method, its implementation "
"should always call the base class method with the same name to access any"
" attributes it needs, for example, ``object.__getattribute__(self, "
"name)``."
msgstr ""

#: ../../reference/datamodel.rst:1559
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`special-lookup`."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__getattr__`` with "
"arguments ``obj``, ``name``."
msgstr ""

#: ../../reference/datamodel.rst:1565
msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""

#: ../../reference/datamodel.rst:1572
msgid ""
"Called when an attribute assignment is attempted.  This is called instead"
" of the normal mechanism (i.e. store the value in the instance "
"dictionary). *name* is the attribute name, *value* is the value to be "
"assigned to it."
msgstr ""

#: ../../reference/datamodel.rst:1576
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it "
"should call the base class method with the same name, for example, "
"``object.__setattr__(self, name, value)``."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__setattr__`` with "
"arguments ``obj``, ``name``, ``value``."
msgstr ""

#: ../../reference/datamodel.rst:1582
msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing "
"event <auditing>` ``object.__setattr__`` with arguments ``obj``, "
"``name``, ``value``."
msgstr ""

#: ../../reference/datamodel.rst:1589
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of "
"assignment.  This should only be implemented if ``del obj.name`` is "
"meaningful for the object."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``object.__delattr__`` with "
"arguments ``obj``, ``name``."
msgstr ""

#: ../../reference/datamodel.rst:1594
msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event"
" <auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""

#: ../../reference/datamodel.rst:1601
msgid ""
"Called when :func:`dir` is called on the object. A sequence must be "
"returned. :func:`dir` converts the returned sequence to a list and sorts "
"it."
msgstr ""

#: ../../reference/datamodel.rst:1606
msgid "Customizing module attribute access"
msgstr ""

#: ../../reference/datamodel.rst:1613
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to "
"customize access to module attributes. The ``__getattr__`` function at "
"the module level should accept one argument which is the name of an "
"attribute and return the computed value or raise an "
":exc:`AttributeError`. If an attribute is not found on a module object "
"through the normal lookup, i.e. :meth:`object.__getattribute__`, then "
"``__getattr__`` is searched in the module ``__dict__`` before raising an "
":exc:`AttributeError`. If found, it is called with the attribute name and"
" the result is returned."
msgstr ""

#: ../../reference/datamodel.rst:1622
msgid ""
"The ``__dir__`` function should accept no arguments, and return a "
"sequence of strings that represents the names accessible on module. If "
"present, this function overrides the standard :func:`dir` search on a "
"module."
msgstr ""

#: ../../reference/datamodel.rst:1626
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of"
" a module object to a subclass of :class:`types.ModuleType`. For "
"example::"
msgstr ""

#: ../../reference/datamodel.rst:1644
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only "
"affect lookups made using the attribute access syntax -- directly "
"accessing the module globals (whether by code within the module, or via a"
" reference to the module's globals dictionary) is unaffected."
msgstr ""

#: ../../reference/datamodel.rst:1649
msgid "``__class__`` module attribute is now writable."
msgstr ""

#: ../../reference/datamodel.rst:1652
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr ""

#: ../../reference/datamodel.rst:1657
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ""

#: ../../reference/datamodel.rst:1658
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr ""

#: ../../reference/datamodel.rst:1664
msgid "Implementing Descriptors"
msgstr ""

#: ../../reference/datamodel.rst:1666
msgid ""
"The following methods only apply when an instance of the class containing"
" the method (a so-called *descriptor* class) appears in an *owner* class "
"(the descriptor must be in either the owner's class dictionary or in the "
"class dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property"
" in the owner class' :attr:`~object.__dict__`."
msgstr ""

#: ../../reference/datamodel.rst:1676
msgid ""
"Called to get the attribute of the owner class (class attribute access) "
"or of an instance of that class (instance attribute access). The optional"
" *owner* argument is the owner class, while *instance* is the instance "
"that the attribute was accessed through, or ``None`` when the attribute "
"is accessed through the *owner*."
msgstr ""

#: ../../reference/datamodel.rst:1682
msgid ""
"This method should return the computed attribute value or raise an "
":exc:`AttributeError` exception."
msgstr ""

#: ../../reference/datamodel.rst:1685
msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification;"
" however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required "
"or not."
msgstr ""

#: ../../reference/datamodel.rst:1694
msgid ""
"Called to set the attribute on an instance *instance* of the owner class "
"to a new value, *value*."
msgstr ""

#: ../../reference/datamodel.rst:1697
msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` "
"for more details."
msgstr ""

#: ../../reference/datamodel.rst:1703
msgid ""
"Called to delete the attribute on an instance *instance* of the owner "
"class."
msgstr ""

#: ../../reference/datamodel.rst:1708
msgid ""
"Called at the time the owning class *owner* is created. The descriptor "
"has been assigned to *name*."
msgstr ""

#: ../../reference/datamodel.rst:1713
msgid ""
":meth:`__set_name__` is only called implicitly as part of the "
":class:`type` constructor, so it will need to be called explicitly with "
"the appropriate parameters when a descriptor is added to a class after "
"initial creation::"
msgstr ""

#: ../../reference/datamodel.rst:1724
msgid "See :ref:`class-object-creation` for more details."
msgstr ""

#: ../../reference/datamodel.rst:1728
msgid ""
"The attribute :attr:`__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting "
"this appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given"
" type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods "
"that are implemented in C)."
msgstr ""

#: ../../reference/datamodel.rst:1739
msgid "Invoking Descriptors"
msgstr ""

#: ../../reference/datamodel.rst:1741
msgid ""
"In general, a descriptor is an object attribute with \"binding "
"behavior\", one whose attribute access has been overridden by methods in "
"the descriptor protocol:  :meth:`__get__`, :meth:`__set__`, and "
":meth:`__delete__`. If any of those methods are defined for an object, it"
" is said to be a descriptor."
msgstr ""

#: ../../reference/datamodel.rst:1746
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup"
" chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``,"
" and continuing through the base classes of ``type(a)`` excluding "
"metaclasses."
msgstr ""

#: ../../reference/datamodel.rst:1751
msgid ""
"However, if the looked-up value is an object defining one of the "
"descriptor methods, then Python may override the default behavior and "
"invoke the descriptor method instead.  Where this occurs in the "
"precedence chain depends on which descriptor methods were defined and how"
" they were called."
msgstr ""

#: ../../reference/datamodel.rst:1756
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How "
"the arguments are assembled depends on ``a``:"
msgstr ""

#: ../../reference/datamodel.rst:1761
msgid "Direct Call"
msgstr ""

#: ../../reference/datamodel.rst:1760
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""

#: ../../reference/datamodel.rst:1765
msgid "Instance Binding"
msgstr ""

#: ../../reference/datamodel.rst:1764
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""

#: ../../reference/datamodel.rst:1769
msgid "Class Binding"
msgstr ""

#: ../../reference/datamodel.rst:1768
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: "
"``A.__dict__['x'].__get__(None, A)``."
msgstr ""

#: ../../reference/datamodel.rst:1775
msgid "Super Binding"
msgstr ""

#: ../../reference/datamodel.rst:1772
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, "
"obj).m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the "
"call: ``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""

#: ../../reference/datamodel.rst:1777
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on"
" which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  "
"If it does not define :meth:`__get__`, then accessing the attribute will "
"return the descriptor object itself unless there is a value in the "
"object's instance dictionary.  If the descriptor defines :meth:`__set__` "
"and/or :meth:`__delete__`, it is a data descriptor; if it defines "
"neither, it is a non-data descriptor.  Normally, data descriptors define "
"both :meth:`__get__` and :meth:`__set__`, while non-data descriptors have"
" just the :meth:`__get__` method.  Data descriptors with :meth:`__set__` "
"and :meth:`__get__` defined always override a redefinition in an instance"
" dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""

#: ../../reference/datamodel.rst:1790
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) "
"are implemented as non-data descriptors.  Accordingly, instances can "
"redefine and override methods.  This allows individual instances to "
"acquire behaviors that differ from other instances of the same class."
msgstr ""

#: ../../reference/datamodel.rst:1795
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""

#: ../../reference/datamodel.rst:1802
msgid "__slots__"
msgstr ""

#: ../../reference/datamodel.rst:1804
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties)"
" and deny the creation of *__dict__* and *__weakref__* (unless explicitly"
" declared in *__slots__* or available in a parent.)"
msgstr ""

#: ../../reference/datamodel.rst:1808
msgid ""
"The space saved over using *__dict__* can be significant. Attribute "
"lookup speed can be significantly improved as well."
msgstr ""

#: ../../reference/datamodel.rst:1813
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves "
"space for the declared variables and prevents the automatic creation of "
"*__dict__* and *__weakref__* for each instance."
msgstr ""

#: ../../reference/datamodel.rst:1820
msgid "Notes on using *__slots__*"
msgstr ""

#: ../../reference/datamodel.rst:1822
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* and "
"*__weakref__* attribute of the instances will always be accessible."
msgstr ""

#: ../../reference/datamodel.rst:1825
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables"
" not listed in the *__slots__* definition.  Attempts to assign to an "
"unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""

#: ../../reference/datamodel.rst:1831
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence "
"of strings in the *__slots__* declaration."
msgstr ""

#: ../../reference/datamodel.rst:1836
msgid ""
"*__slots__* are implemented at the class level by creating descriptors "
"(:ref:`descriptors`) for each variable name.  As a result, class "
"attributes cannot be used to set default values for instance variables "
"defined by *__slots__*; otherwise, the class attribute would overwrite "
"the descriptor assignment."
msgstr ""

#: ../../reference/datamodel.rst:1842
msgid ""
"The action of a *__slots__* declaration is not limited to the class where"
" it is defined.  *__slots__* declared in parents are available in child "
"classes. However, child subclasses will get a *__dict__*  and "
"*__weakref__* unless they also define *__slots__* (which should only "
"contain names of any *additional* slots)."
msgstr ""

#: ../../reference/datamodel.rst:1848
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the"
" meaning of the program undefined.  In the future, a check may be added "
"to prevent this."
msgstr ""

#: ../../reference/datamodel.rst:1853
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-"
"length\" built-in types such as :class:`int`, :class:`bytes` and "
":class:`tuple`."
msgstr ""

#: ../../reference/datamodel.rst:1856
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also"
" be used; however, in the future, special meaning may be assigned to the "
"values corresponding to each key."
msgstr ""

#: ../../reference/datamodel.rst:1860
msgid ""
"*__class__* assignment works only if both classes have the same "
"*__slots__*."
msgstr ""

#: ../../reference/datamodel.rst:1862
msgid ""
"Multiple inheritance with multiple slotted parent classes can be used, "
"but only one parent is allowed to have attributes created by slots (the "
"other bases must have empty slot layouts) - violations raise "
":exc:`TypeError`."
msgstr ""

#: ../../reference/datamodel.rst:1867
msgid ""
"If an iterator is used for *__slots__* then a descriptor is created for "
"each of the iterator's values. However, the *__slots__* attribute will be"
" an empty iterator."
msgstr ""

#: ../../reference/datamodel.rst:1874
msgid "Customizing class creation"
msgstr ""

#: ../../reference/datamodel.rst:1876
msgid ""
"Whenever a class inherits from another class, *__init_subclass__* is "
"called on that class. This way, it is possible to write classes which "
"change the behavior of subclasses. This is closely related to class "
"decorators, but where class decorators only affect the specific class "
"they're applied to, ``__init_subclass__`` solely applies to future "
"subclasses of the class defining the method."
msgstr ""

#: ../../reference/datamodel.rst:1885
msgid ""
"This method is called whenever the containing class is subclassed. *cls* "
"is then the new subclass. If defined as a normal instance method, this "
"method is implicitly converted to a class method."
msgstr ""

#: ../../reference/datamodel.rst:1889
msgid ""
"Keyword arguments which are given to a new class are passed to the "
"parent's class ``__init_subclass__``. For compatibility with other "
"classes using ``__init_subclass__``, one should take out the needed "
"keyword arguments and pass the others over to the base class, as in::"
msgstr ""

#: ../../reference/datamodel.rst:1903
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but"
" raises an error if it is called with any arguments."
msgstr ""

#: ../../reference/datamodel.rst:1908
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. "
"The actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""

#: ../../reference/datamodel.rst:1919
msgid "Metaclasses"
msgstr ""

#: ../../reference/datamodel.rst:1926
msgid ""
"By default, classes are constructed using :func:`type`. The class body is"
" executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""

#: ../../reference/datamodel.rst:1930
msgid ""
"The class creation process can be customized by passing the ``metaclass``"
" keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""

#: ../../reference/datamodel.rst:1944
msgid ""
"Any other keyword arguments that are specified in the class definition "
"are passed through to all metaclass operations described below."
msgstr ""

#: ../../reference/datamodel.rst:1947
msgid "When a class definition is executed, the following steps occur:"
msgstr ""

#: ../../reference/datamodel.rst:1949
msgid "MRO entries are resolved;"
msgstr ""

#: ../../reference/datamodel.rst:1950
msgid "the appropriate metaclass is determined;"
msgstr ""

#: ../../reference/datamodel.rst:1951
msgid "the class namespace is prepared;"
msgstr ""

#: ../../reference/datamodel.rst:1952
msgid "the class body is executed;"
msgstr ""

#: ../../reference/datamodel.rst:1953
msgid "the class object is created."
msgstr ""

#: ../../reference/datamodel.rst:1957
msgid "Resolving MRO entries"
msgstr ""

#: ../../reference/datamodel.rst:1959
msgid ""
"If a base that appears in class definition is not an instance of "
":class:`type`, then an ``__mro_entries__`` method is searched on it. If "
"found, it is called with the original bases tuple. This method must "
"return a tuple of classes that will be used instead of this base. The "
"tuple may be empty, in such case the original base is ignored."
msgstr ""

#: ../../reference/datamodel.rst:1967 ../../reference/datamodel.rst:2157
msgid ":pep:`560` - Core support for typing module and generic types"
msgstr ""

#: ../../reference/datamodel.rst:1971
msgid "Determining the appropriate metaclass"
msgstr ""

#: ../../reference/datamodel.rst:1975
msgid "The appropriate metaclass for a class definition is determined as follows:"
msgstr ""

#: ../../reference/datamodel.rst:1977
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is "
"used;"
msgstr ""

#: ../../reference/datamodel.rst:1978
msgid ""
"if an explicit metaclass is given and it is *not* an instance of "
":func:`type`, then it is used directly as the metaclass;"
msgstr ""

#: ../../reference/datamodel.rst:1980
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or "
"bases are defined, then the most derived metaclass is used."
msgstr ""

#: ../../reference/datamodel.rst:1983
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all "
"specified base classes. The most derived metaclass is one which is a "
"subtype of *all* of these candidate metaclasses. If none of the candidate"
" metaclasses meets that criterion, then the class definition will fail "
"with ``TypeError``."
msgstr ""

#: ../../reference/datamodel.rst:1993
msgid "Preparing the class namespace"
msgstr ""

#: ../../reference/datamodel.rst:1998
msgid ""
"Once the appropriate metaclass has been identified, then the class "
"namespace is prepared. If the metaclass has a ``__prepare__`` attribute, "
"it is called as ``namespace = metaclass.__prepare__(name, bases, "
"**kwds)`` (where the additional keyword arguments, if any, come from the "
"class definition). The ``__prepare__`` method should be implemented as a "
":func:`classmethod`. The namespace returned by ``__prepare__`` is passed "
"in to ``__new__``, but when the final class object is created the "
"namespace is copied into a new ``dict``."
msgstr ""

#: ../../reference/datamodel.rst:2006
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class "
"namespace is initialised as an empty ordered mapping."
msgstr ""

#: ../../reference/datamodel.rst:2012
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr ""

#: ../../reference/datamodel.rst:2016
msgid "Executing the class body"
msgstr ""

#: ../../reference/datamodel.rst:2021
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is "
"that lexical scoping allows the class body (including any methods) to "
"reference names from the current and outer scopes when the class "
"definition occurs inside a function."
msgstr ""

#: ../../reference/datamodel.rst:2027
msgid ""
"However, even when the class definition occurs inside the function, "
"methods defined inside the class still cannot see names defined at the "
"class scope. Class variables must be accessed through the first parameter"
" of instance or class methods, or through the implicit lexically scoped "
"``__class__`` reference described in the next section."
msgstr ""

#: ../../reference/datamodel.rst:2036
msgid "Creating the class object"
msgstr ""

#: ../../reference/datamodel.rst:2043
msgid ""
"Once the class namespace has been populated by executing the class body, "
"the class object is created by calling ``metaclass(name, bases, "
"namespace, **kwds)`` (the additional keywords passed here are the same as"
" those passed to ``__prepare__``)."
msgstr ""

#: ../../reference/datamodel.rst:2048
msgid ""
"This class object is the one that will be referenced by the zero-argument"
" form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of "
":func:`super` to correctly identify the class being defined based on "
"lexical scoping, while the class or instance that was used to make the "
"current call is identified based on the first argument passed to the "
"method."
msgstr ""

#: ../../reference/datamodel.rst:2058
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the "
"metaclass as a ``__classcell__`` entry in the class namespace. If "
"present, this must be propagated up to the ``type.__new__`` call in order"
" for the class to be initialised correctly. Failing to do so will result "
"in a :exc:`RuntimeError` in Python 3.8."
msgstr ""

#: ../../reference/datamodel.rst:2064
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customisation"
" steps are invoked after creating the class object:"
msgstr ""

#: ../../reference/datamodel.rst:2068
msgid ""
"first, ``type.__new__`` collects all of the descriptors in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""

#: ../../reference/datamodel.rst:2070
msgid ""
"second, all of these ``__set_name__`` methods are called with the class "
"being defined and the assigned name of that particular descriptor;"
msgstr ""

#: ../../reference/datamodel.rst:2072
msgid ""
"finally, the :meth:`~object.__init_subclass__` hook is called on the "
"immediate parent of the new class in its method resolution order."
msgstr ""

#: ../../reference/datamodel.rst:2075
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is "
"bound in the local namespace as the defined class."
msgstr ""

#: ../../reference/datamodel.rst:2079
msgid ""
"When a new class is created by ``type.__new__``, the object provided as "
"the namespace parameter is copied to a new ordered mapping and the "
"original object is discarded. The new copy is wrapped in a read-only "
"proxy, which becomes the :attr:`~object.__dict__` attribute of the class "
"object."
msgstr ""

#: ../../reference/datamodel.rst:2086
msgid ":pep:`3135` - New super"
msgstr ""

#: ../../reference/datamodel.rst:2087
msgid "Describes the implicit ``__class__`` closure reference"
msgstr ""

#: ../../reference/datamodel.rst:2091
msgid "Uses for metaclasses"
msgstr ""

#: ../../reference/datamodel.rst:2093
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have "
"been explored include enum, logging, interface checking, automatic "
"delegation, automatic property creation, proxies, frameworks, and "
"automatic resource locking/synchronization."
msgstr ""

#: ../../reference/datamodel.rst:2100
msgid "Customizing instance and subclass checks"
msgstr ""

#: ../../reference/datamodel.rst:2102
msgid ""
"The following methods are used to override the default behavior of the "
":func:`isinstance` and :func:`issubclass` built-in functions."
msgstr ""

#: ../../reference/datamodel.rst:2105
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these "
"methods in order to allow the addition of Abstract Base Classes (ABCs) as"
" \"virtual base classes\" to any class or type (including built-in "
"types), including other ABCs."
msgstr ""

#: ../../reference/datamodel.rst:2112
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement "
"``isinstance(instance, class)``."
msgstr ""

#: ../../reference/datamodel.rst:2119
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement "
"``issubclass(subclass, class)``."
msgstr ""

#: ../../reference/datamodel.rst:2124
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class."
"  They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on "
"instances, only in this case the instance is itself a class."
msgstr ""

#: ../../reference/datamodel.rst:2135
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ""

#: ../../reference/datamodel.rst:2132
msgid ""
"Includes the specification for customizing :func:`isinstance` and "
":func:`issubclass` behavior through :meth:`~class.__instancecheck__` and "
":meth:`~class.__subclasscheck__`, with motivation for this functionality "
"in the context of adding Abstract Base Classes (see the :mod:`abc` "
"module) to the language."
msgstr ""

#: ../../reference/datamodel.rst:2140
msgid "Emulating generic types"
msgstr ""

#: ../../reference/datamodel.rst:2142
msgid ""
"One can implement the generic class syntax as specified by :pep:`484` "
"(for example ``List[int]``) by defining a special method:"
msgstr ""

#: ../../reference/datamodel.rst:2147
msgid ""
"Return an object representing the specialization of a generic class by "
"type arguments found in *key*."
msgstr ""

#: ../../reference/datamodel.rst:2150
msgid ""
"This method is looked up on the class object itself, and when defined in "
"the class body, this method is implicitly a class method.  Note, this "
"mechanism is primarily reserved for use with static type hints, other "
"usage is discouraged."
msgstr ""

#: ../../reference/datamodel.rst:2163
msgid "Emulating callable objects"
msgstr ""

#: ../../reference/datamodel.rst:2170
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to "
"``type(x).__call__(x, arg1, ...)``."
msgstr ""

#: ../../reference/datamodel.rst:2177
msgid "Emulating container types"
msgstr ""

#: ../../reference/datamodel.rst:2179
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings "
"(like dictionaries), but can represent other containers as well.  The "
"first set of methods is used either to emulate a sequence or to emulate a"
" mapping; the difference is that for a sequence, the allowable keys "
"should be the integers *k* for which ``0 <= k < N`` where *N* is the "
"length of the sequence, or slice objects, which define a range of items."
"  It is also recommended that mappings provide the methods :meth:`keys`, "
":meth:`values`, :meth:`items`, :meth:`get`, :meth:`clear`, "
":meth:`setdefault`, :meth:`pop`, :meth:`popitem`, :meth:`!copy`, and "
":meth:`update` behaving similar to those for Python's standard dictionary"
" objects.  The :mod:`collections.abc` module provides a "
":class:`~collections.abc.MutableMapping` abstract base class to help "
"create those methods from a base set of :meth:`__getitem__`, "
":meth:`__setitem__`, :meth:`__delitem__`, and :meth:`keys`. Mutable "
"sequences should provide methods :meth:`append`, :meth:`count`, "
":meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, "
":meth:`remove`, :meth:`reverse` and :meth:`sort`, like Python standard "
"list objects.  Finally, sequence types should implement addition (meaning"
" concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, "
":meth:`__mul__`, :meth:`__rmul__` and :meth:`__imul__` described below; "
"they should not define other numerical operators.  It is recommended that"
" both mappings and sequences implement the :meth:`__contains__` method to"
" allow efficient use of the ``in`` operator; for mappings, ``in`` should "
"search the mapping's keys; for sequences, it should search through the "
"values.  It is further recommended that both mappings and sequences "
"implement the :meth:`__iter__` method to allow efficient iteration "
"through the container; for mappings, :meth:`__iter__` should iterate "
"through the object's keys; for sequences, it should iterate through the "
"values."
msgstr ""

#: ../../reference/datamodel.rst:2214
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the"
" length of the object, an integer ``>=`` 0.  Also, an object that doesn't"
" define a :meth:`__bool__` method and whose :meth:`__len__` method "
"returns zero is considered to be false in a Boolean context."
msgstr ""

#: ../../reference/datamodel.rst:2221
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If "
"the length is larger than :attr:`!sys.maxsize` some features (such as "
":func:`len`) may raise :exc:`OverflowError`.  To prevent raising "
":exc:`!OverflowError` by truth value testing, an object must define a "
":meth:`__bool__` method."
msgstr ""

#: ../../reference/datamodel.rst:2230
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an "
"estimated length for the object (which may be greater or less than the "
"actual length). The length must be an integer ``>=`` 0. The return value "
"may also be :const:`NotImplemented`, which is treated the same as if the "
"``__length_hint__`` method didn't exist at all. This method is purely an "
"optimization and is never required for correctness."
msgstr ""

#: ../../reference/datamodel.rst:2244
msgid ""
"Slicing is done exclusively with the following three methods.  A call "
"like ::"
msgstr ""

#: ../../reference/datamodel.rst:2248
msgid "is translated to ::"
msgstr ""

#: ../../reference/datamodel.rst:2252
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr ""

#: ../../reference/datamodel.rst:2257
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the "
"special interpretation of negative indexes (if the class wishes to "
"emulate a sequence type) is up to the :meth:`__getitem__` method. If "
"*key* is of an inappropriate type, :exc:`TypeError` may be raised; if of "
"a value outside the set of indexes for the sequence (after any special "
"interpretation of negative values), :exc:`IndexError` should be raised. "
"For mapping types, if *key* is missing (not in the container), "
":exc:`KeyError` should be raised."
msgstr ""

#: ../../reference/datamodel.rst:2268
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""

#: ../../reference/datamodel.rst:2274
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the"
" objects support changes to the values for keys, or if new keys can be "
"added, or for sequences if elements can be replaced.  The same exceptions"
" should be raised for improper *key* values as for the "
":meth:`__getitem__` method."
msgstr ""

#: ../../reference/datamodel.rst:2283
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the"
" objects support removal of keys, or for sequences if elements can be "
"removed from the sequence.  The same exceptions should be raised for "
"improper *key* values as for the :meth:`__getitem__` method."
msgstr ""

#: ../../reference/datamodel.rst:2292
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement "
"``self[key]`` for dict subclasses when key is not in the dictionary."
msgstr ""

#: ../../reference/datamodel.rst:2298
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys "
"of the container."
msgstr ""

#: ../../reference/datamodel.rst:2302
msgid ""
"Iterator objects also need to implement this method; they are required to"
" return themselves.  For more information on iterator objects, see "
":ref:`typeiter`."
msgstr ""

#: ../../reference/datamodel.rst:2308
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse"
" iteration.  It should return a new iterator object that iterates over "
"all the objects in the container in reverse order."
msgstr ""

#: ../../reference/datamodel.rst:2312
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` "
"and :meth:`__getitem__`).  Objects that support the sequence protocol "
"should only provide :meth:`__reversed__` if they can provide an "
"implementation that is more efficient than the one provided by "
":func:`reversed`."
msgstr ""

#: ../../reference/datamodel.rst:2319
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, "
"container objects can supply the following special method with a more "
"efficient implementation, which also does not require the object be "
"iterable."
msgstr ""

#: ../../reference/datamodel.rst:2326
msgid ""
"Called to implement membership test operators.  Should return true if "
"*item* is in *self*, false otherwise.  For mapping objects, this should "
"consider the keys of the mapping rather than the values or the key-item "
"pairs."
msgstr ""

#: ../../reference/datamodel.rst:2330
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence "
"iteration protocol via :meth:`__getitem__`, see :ref:`this section in the"
" language reference <membership-test-details>`."
msgstr ""

#: ../../reference/datamodel.rst:2339
msgid "Emulating numeric types"
msgstr ""

#: ../../reference/datamodel.rst:2341
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind"
" of number implemented (e.g., bitwise operations for non-integral "
"numbers) should be left undefined."
msgstr ""

#: ../../reference/datamodel.rst:2367
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance,"
" to evaluate the expression ``x + y``, where *x* is an instance of a "
"class that has an :meth:`__add__` method, ``x.__add__(y)`` is called.  "
"The :meth:`__divmod__` method should be the equivalent to using "
":meth:`__floordiv__` and :meth:`__mod__`; it should not be related to "
":meth:`__truediv__`.  Note that :meth:`__pow__` should be defined to "
"accept an optional third argument if the ternary version of the built-in "
":func:`pow` function is to be supported."
msgstr ""

#: ../../reference/datamodel.rst:2378
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr ""

#: ../../reference/datamodel.rst:2401
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected "
"(swapped) operands.  These functions are only called if the left operand "
"does not support the corresponding operation [#]_ and the operands are of"
" different types. [#]_ For instance, to evaluate the expression ``x - "
"y``, where *y* is an instance of a class that has an :meth:`__rsub__` "
"method, ``y.__rsub__(x)`` is called if ``x.__sub__(y)`` returns "
"*NotImplemented*."
msgstr ""

#: ../../reference/datamodel.rst:2412
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""

#: ../../reference/datamodel.rst:2417
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method"
" for the operation, this method will be called before the left operand's "
"non-reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""

#: ../../reference/datamodel.rst:2438
msgid ""
"These methods are called to implement the augmented arithmetic "
"assignments (``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, "
"``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``).  These methods should"
" attempt to do the operation in-place (modifying *self*) and return the "
"result (which could be, but does not have to be, *self*).  If a specific "
"method is not defined, the augmented assignment falls back to the normal "
"methods.  For instance, if *x* is an instance of a class with an "
":meth:`__iadd__` method, ``x += y`` is equivalent to ``x = "
"x.__iadd__(y)`` . Otherwise, ``x.__add__(y)`` and ``y.__radd__(x)`` are "
"considered, as with the evaluation of ``x + y``. In certain situations, "
"augmented assignment can result in unexpected errors (see :ref:`faq-"
"augmented-assignment-tuple-error`), but this behavior is in fact part of "
"the data model."
msgstr ""

#: ../../reference/datamodel.rst:2453
msgid ""
"Due to a bug in the dispatching mechanism for ``**=``, a class that "
"defines :meth:`__ipow__` but returns ``NotImplemented`` would fail to "
"fall back to ``x.__pow__(y)`` and ``y.__rpow__(x)``. This bug is fixed in"
" Python 3.10."
msgstr ""

#: ../../reference/datamodel.rst:2466
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, "
":func:`abs` and ``~``)."
msgstr ""

#: ../../reference/datamodel.rst:2479
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` "
"and :func:`float`.  Should return a value of the appropriate type."
msgstr ""

#: ../../reference/datamodel.rst:2486
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is "
"an integer type.  Must return an integer."
msgstr ""

#: ../../reference/datamodel.rst:2492
msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` "
"and :func:`complex` fall back to :meth:`__index__`."
msgstr ""

#: ../../reference/datamodel.rst:2504
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and "
":func:`~math.ceil`. Unless *ndigits* is passed to :meth:`!__round__` all "
"these methods should return the value of the object truncated to an "
":class:`~numbers.Integral` (typically an :class:`int`)."
msgstr ""

#: ../../reference/datamodel.rst:2510
msgid ""
"The built-in function :func:`int` falls back to :meth:`__trunc__` if "
"neither :meth:`__int__` nor :meth:`__index__` is defined."
msgstr ""

#: ../../reference/datamodel.rst:2517
msgid "With Statement Context Managers"
msgstr ""

#: ../../reference/datamodel.rst:2519
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to"
" be established when executing a :keyword:`with` statement. The context "
"manager handles the entry into, and the exit from, the desired runtime "
"context for the execution of the block of code.  Context managers are "
"normally invoked using the :keyword:`!with` statement (described in "
"section :ref:`with`), but can also be used by directly invoking their "
"methods."
msgstr ""

#: ../../reference/datamodel.rst:2530
msgid ""
"Typical uses of context managers include saving and restoring various "
"kinds of global state, locking and unlocking resources, closing opened "
"files, etc."
msgstr ""

#: ../../reference/datamodel.rst:2533
msgid "For more information on context managers, see :ref:`typecontextmanager`."
msgstr ""

#: ../../reference/datamodel.rst:2538
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified"
" in the :keyword:`!as` clause of the statement, if any."
msgstr ""

#: ../../reference/datamodel.rst:2545
msgid ""
"Exit the runtime context related to this object. The parameters describe "
"the exception that caused the context to be exited. If the context was "
"exited without an exception, all three arguments will be :const:`None`."
msgstr ""

#: ../../reference/datamodel.rst:2549
msgid ""
"If an exception is supplied, and the method wishes to suppress the "
"exception (i.e., prevent it from being propagated), it should return a "
"true value. Otherwise, the exception will be processed normally upon exit"
" from this method."
msgstr ""

#: ../../reference/datamodel.rst:2553
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""

#: ../../reference/datamodel.rst:2567
msgid "Special method lookup"
msgstr ""

#: ../../reference/datamodel.rst:2569
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""

#: ../../reference/datamodel.rst:2584
msgid ""
"The rationale behind this behaviour lies with a number of special methods"
" such as :meth:`__hash__` and :meth:`__repr__` that are implemented by "
"all objects, including type objects. If the implicit lookup of these "
"methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""

#: ../../reference/datamodel.rst:2597
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way"
" is sometimes referred to as 'metaclass confusion', and is avoided by "
"bypassing the instance when looking up special methods::"
msgstr ""

#: ../../reference/datamodel.rst:2606
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the "
":meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""

#: ../../reference/datamodel.rst:2632
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides"
" significant scope for speed optimisations within the interpreter, at the"
" cost of some flexibility in the handling of special methods (the special"
" method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""

#: ../../reference/datamodel.rst:2647
msgid "Awaitable Objects"
msgstr ""

#: ../../reference/datamodel.rst:2649
msgid ""
"An :term:`awaitable` object generally implements an :meth:`__await__` "
"method. :term:`Coroutine objects <coroutine>` returned from "
":keyword:`async def` functions are awaitable."
msgstr ""

#: ../../reference/datamodel.rst:2655
msgid ""
"The :term:`generator iterator` objects returned from generators decorated"
" with :func:`types.coroutine` or :func:`asyncio.coroutine` are also "
"awaitable, but they do not implement :meth:`__await__`."
msgstr ""

#: ../../reference/datamodel.rst:2661
msgid ""
"Must return an :term:`iterator`.  Should be used to implement "
":term:`awaitable` objects.  For instance, :class:`asyncio.Future` "
"implements this method to be compatible with the :keyword:`await` "
"expression."
msgstr ""

#: ../../reference/datamodel.rst:2667
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ""

#: ../../reference/datamodel.rst:2673
msgid "Coroutine Objects"
msgstr ""

#: ../../reference/datamodel.rst:2675
msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling :meth:`__await__` and "
"iterating over the result.  When the coroutine has finished executing and"
" returns, the iterator raises :exc:`StopIteration`, and the exception's "
":attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  "
"Coroutines should not directly raise unhandled :exc:`StopIteration` "
"exceptions."
msgstr ""

#: ../../reference/datamodel.rst:2683
msgid ""
"Coroutines also have the methods listed below, which are analogous to "
"those of generators (see :ref:`generator-methods`).  However, unlike "
"generators, coroutines do not directly support iteration."
msgstr ""

#: ../../reference/datamodel.rst:2687
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr ""

#: ../../reference/datamodel.rst:2693
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, "
"this is equivalent to advancing the iterator returned by "
":meth:`__await__`.  If *value* is not ``None``, this method delegates to "
"the :meth:`~generator.send` method of the iterator that caused the "
"coroutine to suspend.  The result (return value, :exc:`StopIteration`, or"
" other exception) is the same as when iterating over the "
":meth:`__await__` return value, described above."
msgstr ""

#: ../../reference/datamodel.rst:2703
msgid ""
"Raises the specified exception in the coroutine.  This method delegates "
"to the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception "
"is raised at the suspension point.  The result (return value, "
":exc:`StopIteration`, or other exception) is the same as when iterating "
"over the :meth:`__await__` return value, described above.  If the "
"exception is not caught in the coroutine, it propagates back to the "
"caller."
msgstr ""

#: ../../reference/datamodel.rst:2714
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has "
"such a method.  Then it raises :exc:`GeneratorExit` at the suspension "
"point, causing the coroutine to immediately clean itself up. Finally, the"
" coroutine is marked as having finished executing, even if it was never "
"started."
msgstr ""

#: ../../reference/datamodel.rst:2722
msgid ""
"Coroutine objects are automatically closed using the above process when "
"they are about to be destroyed."
msgstr ""

#: ../../reference/datamodel.rst:2728
msgid "Asynchronous Iterators"
msgstr ""

#: ../../reference/datamodel.rst:2730
msgid ""
"An *asynchronous iterator* can call asynchronous code in its "
"``__anext__`` method."
msgstr ""

#: ../../reference/datamodel.rst:2733
msgid "Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr ""

#: ../../reference/datamodel.rst:2737
msgid "Must return an *asynchronous iterator* object."
msgstr ""

#: ../../reference/datamodel.rst:2741
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is "
"over."
msgstr ""

#: ../../reference/datamodel.rst:2744
msgid "An example of an asynchronous iterable object::"
msgstr ""

#: ../../reference/datamodel.rst:2761
msgid ""
"Prior to Python 3.7, ``__aiter__`` could return an *awaitable* that would"
" resolve to an :term:`asynchronous iterator <asynchronous iterator>`."
msgstr ""

#: ../../reference/datamodel.rst:2766
msgid ""
"Starting with Python 3.7, ``__aiter__`` must return an asynchronous "
"iterator object.  Returning anything else will result in a "
":exc:`TypeError` error."
msgstr ""

#: ../../reference/datamodel.rst:2774
msgid "Asynchronous Context Managers"
msgstr ""

#: ../../reference/datamodel.rst:2776
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""

#: ../../reference/datamodel.rst:2779
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr ""

#: ../../reference/datamodel.rst:2783
msgid ""
"Semantically similar to :meth:`__enter__`, the only difference being that"
" it must return an *awaitable*."
msgstr ""

#: ../../reference/datamodel.rst:2788
msgid ""
"Semantically similar to :meth:`__exit__`, the only difference being that "
"it must return an *awaitable*."
msgstr ""

#: ../../reference/datamodel.rst:2791
msgid "An example of an asynchronous context manager class::"
msgstr ""

#: ../../reference/datamodel.rst:2805
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it "
"can lead to some very strange behaviour if it is handled incorrectly."
msgstr ""

#: ../../reference/datamodel.rst:2809
msgid ""
"The :meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, and "
":meth:`__contains__` methods have special handling for this; others will "
"still raise a :exc:`TypeError`, but may do so by relying on the behavior "
"that ``None`` is not callable."
msgstr ""

#: ../../reference/datamodel.rst:2814
msgid ""
"\"Does not support\" here means that the class has no such method, or the"
" method returns ``NotImplemented``.  Do not set the method to ``None`` if"
" you want to force fallback to the right operand's reflected methodthat "
"will instead have the opposite effect of explicitly *blocking* such "
"fallback."
msgstr ""

#: ../../reference/datamodel.rst:2820
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method -- such as :meth:`__add__` -- fails then the overall operation is "
"not supported, which is why the reflected method is not called."
msgstr ""

#: ../../reference/executionmodel.rst:6
msgid "Execution model"
msgstr ""

#: ../../reference/executionmodel.rst:15
msgid "Structure of a program"
msgstr ""

#: ../../reference/executionmodel.rst:19
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a "
"piece of Python program text that is executed as a unit. The following "
"are blocks: a module, a function body, and a class definition. Each "
"command typed interactively is a block.  A script file (a file given as "
"standard input to the interpreter or specified as a command line argument"
" to the interpreter) is a code block.  A script command (a command "
"specified on the interpreter command line with the :option:`-c` option) "
"is a code block.  The string argument passed to the built-in functions "
":func:`eval` and :func:`exec` is a code block."
msgstr ""

#: ../../reference/executionmodel.rst:31
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where"
" and how execution continues after the code block's execution has "
"completed."
msgstr ""

#: ../../reference/executionmodel.rst:38
msgid "Naming and binding"
msgstr ""

#: ../../reference/executionmodel.rst:47
msgid "Binding of names"
msgstr ""

#: ../../reference/executionmodel.rst:53
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ""

#: ../../reference/executionmodel.rst:57
msgid ""
"The following constructs bind names: formal parameters to functions, "
":keyword:`import` statements, class and function definitions (these bind "
"the class or function name in the defining block), and targets that are "
"identifiers if occurring in an assignment, :keyword:`for` loop header, or"
" after :keyword:`!as` in a :keyword:`with` statement or :keyword:`except`"
" clause. The :keyword:`!import` statement of the form ``from ... import "
"*`` binds all names defined in the imported module, except those "
"beginning with an underscore.  This form may only be used at the module "
"level."
msgstr ""

#: ../../reference/executionmodel.rst:67
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound"
" for this purpose (though the actual semantics are to unbind the name)."
msgstr ""

#: ../../reference/executionmodel.rst:70
msgid ""
"Each assignment or import statement occurs within a block defined by a "
"class or function definition or at the module level (the top-level code "
"block)."
msgstr ""

#: ../../reference/executionmodel.rst:75
msgid ""
"If a name is bound in a block, it is a local variable of that block, "
"unless declared as :keyword:`nonlocal` or :keyword:`global`.  If a name "
"is bound at the module level, it is a global variable.  (The variables of"
" the module code block are local and global.)  If a variable is used in a"
" code block but not defined there, it is a :dfn:`free variable`."
msgstr ""

#: ../../reference/executionmodel.rst:81
msgid ""
"Each occurrence of a name in the program text refers to the "
":dfn:`binding` of that name established by the following name resolution "
"rules."
msgstr ""

#: ../../reference/executionmodel.rst:87
msgid "Resolution of names"
msgstr ""

#: ../../reference/executionmodel.rst:91
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a "
"local variable is defined in a block, its scope includes that block.  If "
"the definition occurs in a function block, the scope extends to any "
"blocks contained within the defining one, unless a contained block "
"introduces a different binding for the name."
msgstr ""

#: ../../reference/executionmodel.rst:99
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""

#: ../../reference/executionmodel.rst:107
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. "
"If the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the "
"name is used, an :exc:`UnboundLocalError` exception is raised. "
":exc:`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""

#: ../../reference/executionmodel.rst:113
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses"
" of the name within the block are treated as references to the current "
"block.  This can lead to errors when a name is used within a block before"
" it is bound.  This rule is subtle.  Python lacks declarations and allows"
" name binding operations to occur anywhere within a code block.  The "
"local variables of a code block can be determined by scanning the entire "
"text of the block for name binding operations."
msgstr ""

#: ../../reference/executionmodel.rst:120
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the"
" name specified in the statement refer to the binding of that name in the"
" top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module "
"containing the code block, and the builtins namespace, the namespace of "
"the module :mod:`builtins`.  The global namespace is searched first.  If "
"the name is not found there, the builtins namespace is searched.  The "
":keyword:`!global` statement must precede all uses of the name."
msgstr ""

#: ../../reference/executionmodel.rst:129
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""

#: ../../reference/executionmodel.rst:135
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. "
":exc:`SyntaxError` is raised at compile time if the given name does not "
"exist in any enclosing function scope."
msgstr ""

#: ../../reference/executionmodel.rst:142
msgid ""
"The namespace for a module is automatically created the first time a "
"module is imported.  The main module for a script is always called "
":mod:`__main__`."
msgstr ""

#: ../../reference/executionmodel.rst:145
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` "
"are special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references "
"follow the normal rules for name resolution with an exception that "
"unbound local variables are looked up in the global namespace. The "
"namespace of the class definition becomes the attribute dictionary of the"
" class. The scope of names defined in a class block is limited to the "
"class block; it does not extend to the code blocks of methods -- this "
"includes comprehensions and generator expressions since they are "
"implemented using a function scope.  This means that the following will "
"fail::"
msgstr ""

#: ../../reference/executionmodel.rst:163
msgid "Builtins and restricted execution"
msgstr ""

#: ../../reference/executionmodel.rst:169
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation"
" detail.  Users wanting to override values in the builtins namespace "
"should :keyword:`import` the :mod:`builtins` module and modify its "
"attributes appropriately."
msgstr ""

#: ../../reference/executionmodel.rst:174
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case "
"the module's dictionary is used).  By default, when in the "
":mod:`__main__` module, ``__builtins__`` is the built-in module "
":mod:`builtins`; when in any other module, ``__builtins__`` is an alias "
"for the dictionary of the :mod:`builtins` module itself."
msgstr ""

#: ../../reference/executionmodel.rst:186
msgid "Interaction with dynamic features"
msgstr ""

#: ../../reference/executionmodel.rst:188
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time."
" This means that the following code will print 42::"
msgstr ""

#: ../../reference/executionmodel.rst:199
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the "
"full environment for resolving names.  Names may be resolved in the local"
" and global namespaces of the caller.  Free variables are not resolved in"
" the nearest enclosing namespace, but in the global namespace.  [#]_ The "
":func:`exec` and :func:`eval` functions have optional arguments to "
"override the global and local namespace.  If only one namespace is "
"specified, it is used for both."
msgstr ""

#: ../../reference/executionmodel.rst:210
msgid "Exceptions"
msgstr ""

#: ../../reference/executionmodel.rst:221
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a"
" code block in order to handle errors or other exceptional conditions.  "
"An exception is *raised* at the point where the error is detected; it may"
" be *handled* by the surrounding code block or by any code block that "
"directly or indirectly invoked the code block where the error occurred."
msgstr ""

#: ../../reference/executionmodel.rst:227
msgid ""
"The Python interpreter raises an exception when it detects a run-time "
"error (such as division by zero).  A Python program can also explicitly "
"raise an exception with the :keyword:`raise` statement. Exception "
"handlers are specified with the :keyword:`try` ... :keyword:`except` "
"statement.  The :keyword:`finally` clause of such a statement can be used"
" to specify cleanup code which does not handle the exception, but is "
"executed whether an exception occurred or not in the preceding code."
msgstr ""

#: ../../reference/executionmodel.rst:237
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer "
"level, but it cannot repair the cause of the error and retry the failing "
"operation (except by re-entering the offending piece of code from the "
"top)."
msgstr ""

#: ../../reference/executionmodel.rst:244
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is "
":exc:`SystemExit`."
msgstr ""

#: ../../reference/executionmodel.rst:248
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` "
"clause is selected depending on the class of the instance: it must "
"reference the class of the instance or a base class thereof.  The "
"instance can be received by the handler and can carry additional "
"information about the exceptional condition."
msgstr ""

#: ../../reference/executionmodel.rst:255
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should "
"not be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""

#: ../../reference/executionmodel.rst:259
msgid ""
"See also the description of the :keyword:`try` statement in section "
":ref:`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""

#: ../../reference/executionmodel.rst:265
msgid ""
"This limitation occurs because the code that is executed by these "
"operations is not available at the time the module is compiled."
msgstr ""

#: ../../reference/expressions.rst:6
msgid "Expressions"
msgstr ""

#: ../../reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in "
"Python."
msgstr ""

#: ../../reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF "
"notation will be used to describe syntax, not lexical analysis.  When "
"(one alternative of) a syntax rule has the form"
msgstr ""

#: ../../reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are "
"the same as for ``othername``."
msgstr ""

#: ../../reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr ""

#: ../../reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type\", this means that the "
"operator implementation for built-in types works as follows:"
msgstr ""

#: ../../reference/expressions.rst:34
msgid "If either argument is a complex number, the other is converted to complex;"
msgstr ""

#: ../../reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""

#: ../../reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr ""

#: ../../reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a "
"left argument to the '%' operator).  Extensions must define their own "
"conversion behavior."
msgstr ""

#: ../../reference/expressions.rst:49
msgid "Atoms"
msgstr ""

#: ../../reference/expressions.rst:53
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are"
" identifiers or literals.  Forms enclosed in parentheses, brackets or "
"braces are also categorized syntactically as atoms.  The syntax for atoms"
" is:"
msgstr ""

#: ../../reference/expressions.rst:66
msgid "Identifiers (Names)"
msgstr ""

#: ../../reference/expressions.rst:70
msgid ""
"An identifier occurring as an atom is a name.  See section "
":ref:`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""

#: ../../reference/expressions.rst:76
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a "
":exc:`NameError` exception."
msgstr ""

#: ../../reference/expressions.rst:84
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does "
"not end in two or more underscores, it is considered a :dfn:`private "
"name` of that class. Private names are transformed to a longer form "
"before code is generated for them.  The transformation inserts the class "
"name, with leading underscores removed and a single underscore inserted, "
"in front of the name.  For example, the identifier ``__spam`` occurring "
"in a class named ``Ham`` will be transformed to ``_Ham__spam``.  This "
"transformation is independent of the syntactical context in which the "
"identifier is used.  If the transformed name is extremely long (longer "
"than 255 characters), implementation defined truncation may happen. If "
"the class name consists only of underscores, no transformation is done."
msgstr ""

#: ../../reference/expressions.rst:100 ../../reference/lexical_analysis.rst:396
msgid "Literals"
msgstr ""

#: ../../reference/expressions.rst:104
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""

#: ../../reference/expressions.rst:110
msgid ""
"Evaluation of a literal yields an object of the given type (string, "
"bytes, integer, floating point number, complex number) with the given "
"value.  The value may be approximated in the case of floating point and "
"imaginary (complex) literals.  See section :ref:`literals` for details."
msgstr ""

#: ../../reference/expressions.rst:119
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of "
"literals with the same value (either the same occurrence in the program "
"text or a different occurrence) may obtain the same object or a different"
" object with the same value."
msgstr ""

#: ../../reference/expressions.rst:129
msgid "Parenthesized forms"
msgstr ""

#: ../../reference/expressions.rst:135
msgid ""
"A parenthesized form is an optional expression list enclosed in "
"parentheses:"
msgstr ""

#: ../../reference/expressions.rst:140
msgid ""
"A parenthesized expression list yields whatever that expression list "
"yields: if the list contains at least one comma, it yields a tuple; "
"otherwise, it yields the single expression that makes up the expression "
"list."
msgstr ""

#: ../../reference/expressions.rst:146
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples "
"are immutable, the same rules as for literals apply (i.e., two "
"occurrences of the empty tuple may or may not yield the same object)."
msgstr ""

#: ../../reference/expressions.rst:154
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of "
"the comma operator.  The exception is the empty tuple, for which "
"parentheses *are* required --- allowing unparenthesized \"nothing\" in "
"expressions would cause ambiguities and allow common typos to pass "
"uncaught."
msgstr ""

#: ../../reference/expressions.rst:163
msgid "Displays for lists, sets and dictionaries"
msgstr ""

#: ../../reference/expressions.rst:167
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""

#: ../../reference/expressions.rst:170
msgid "either the container contents are listed explicitly, or"
msgstr ""

#: ../../reference/expressions.rst:172
msgid ""
"they are computed via a set of looping and filtering instructions, called"
" a :dfn:`comprehension`."
msgstr ""

#: ../../reference/expressions.rst:180
msgid "Common syntax elements for comprehensions are:"
msgstr ""

#: ../../reference/expressions.rst:188
msgid ""
"The comprehension consists of a single expression followed by at least "
"one :keyword:`!for` clause and zero or more :keyword:`!for` or "
":keyword:`!if` clauses. In this case, the elements of the new container "
"are those that would be produced by considering each of the "
":keyword:`!for` or :keyword:`!if` clauses a block, nesting from left to "
"right, and evaluating the expression to produce an element each time the "
"innermost block is reached."
msgstr ""

#: ../../reference/expressions.rst:195
msgid ""
"However, aside from the iterable expression in the leftmost "
":keyword:`!for` clause, the comprehension is executed in a separate "
"implicitly nested scope. This ensures that names assigned to in the "
"target list don't \"leak\" into the enclosing scope."
msgstr ""

#: ../../reference/expressions.rst:199
msgid ""
"The iterable expression in the leftmost :keyword:`!for` clause is "
"evaluated directly in the enclosing scope and then passed as an argument "
"to the implicitly nested scope. Subsequent :keyword:`!for` clauses and "
"any filter condition in the leftmost :keyword:`!for` clause cannot be "
"evaluated in the enclosing scope as they may depend on the values "
"obtained from the leftmost iterable. For example: ``[x*y for x in "
"range(10) for y in range(x, x+10)]``."
msgstr ""

#: ../../reference/expressions.rst:206
msgid ""
"To ensure the comprehension always results in a container of the "
"appropriate type, ``yield`` and ``yield from`` expressions are prohibited"
" in the implicitly nested scope."
msgstr ""

#: ../../reference/expressions.rst:213
msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an "
":keyword:`!async for` clause may be used to iterate over a "
":term:`asynchronous iterator`. A comprehension in an :keyword:`!async "
"def` function may consist of either a :keyword:`!for` or :keyword:`!async"
" for` clause following the leading expression, may contain additional "
":keyword:`!for` or :keyword:`!async for` clauses, and may also use "
":keyword:`await` expressions. If a comprehension contains either "
":keyword:`!async for` clauses or :keyword:`!await` expressions it is "
"called an :dfn:`asynchronous comprehension`.  An asynchronous "
"comprehension may suspend the execution of the coroutine function in "
"which it appears. See also :pep:`530`."
msgstr ""

#: ../../reference/expressions.rst:225
msgid "Asynchronous comprehensions were introduced."
msgstr ""

#: ../../reference/expressions.rst:228 ../../reference/expressions.rst:401
msgid "``yield`` and ``yield from`` prohibited in the implicitly nested scope."
msgstr ""

#: ../../reference/expressions.rst:235
msgid "List displays"
msgstr ""

#: ../../reference/expressions.rst:245
msgid ""
"A list display is a possibly empty series of expressions enclosed in "
"square brackets:"
msgstr ""

#: ../../reference/expressions.rst:251
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a "
"comprehension is supplied, the list is constructed from the elements "
"resulting from the comprehension."
msgstr ""

#: ../../reference/expressions.rst:261
msgid "Set displays"
msgstr ""

#: ../../reference/expressions.rst:270
msgid ""
"A set display is denoted by curly braces and distinguishable from "
"dictionary displays by the lack of colons separating keys and values:"
msgstr ""

#: ../../reference/expressions.rst:276
msgid ""
"A set display yields a new mutable set object, the contents being "
"specified by either a sequence of expressions or a comprehension.  When a"
" comma-separated list of expressions is supplied, its elements are "
"evaluated from left to right and added to the set object.  When a "
"comprehension is supplied, the set is constructed from the elements "
"resulting from the comprehension."
msgstr ""

#: ../../reference/expressions.rst:282
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs "
"an empty dictionary."
msgstr ""

#: ../../reference/expressions.rst:289
msgid "Dictionary displays"
msgstr ""

#: ../../reference/expressions.rst:300
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs "
"enclosed in curly braces:"
msgstr ""

#: ../../reference/expressions.rst:309
msgid "A dictionary display yields a new dictionary object."
msgstr ""

#: ../../reference/expressions.rst:311
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: "
"each key object is used as a key into the dictionary to store the "
"corresponding datum.  This means that you can specify the same key "
"multiple times in the key/datum list, and the final dictionary's value "
"for that key will be the last one given."
msgstr ""

#: ../../reference/expressions.rst:321
msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand"
" must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier key/datum"
" pairs and earlier dictionary unpackings."
msgstr ""

#: ../../reference/expressions.rst:326
msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr ""

#: ../../reference/expressions.rst:329
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs "
"two expressions separated with a colon followed by the usual \"for\" and "
"\"if\" clauses. When the comprehension is run, the resulting key and "
"value elements are inserted in the new dictionary in the order they are "
"produced."
msgstr ""

#: ../../reference/expressions.rst:337
msgid ""
"Restrictions on the types of the key values are listed earlier in section"
" :ref:`types`.  (To summarize, the key type should be :term:`hashable`, "
"which excludes all mutable objects.)  Clashes between duplicate keys are "
"not detected; the last datum (textually rightmost in the display) stored "
"for a given key value prevails."
msgstr ""

#: ../../reference/expressions.rst:343
msgid ""
"Prior to Python 3.8, in dict comprehensions, the evaluation order of key "
"and value was not well-defined.  In CPython, the value was evaluated "
"before the key.  Starting with 3.8, the key is evaluated before the "
"value, as proposed by :pep:`572`."
msgstr ""

#: ../../reference/expressions.rst:353
msgid "Generator expressions"
msgstr ""

#: ../../reference/expressions.rst:360
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""

#: ../../reference/expressions.rst:365
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""

#: ../../reference/expressions.rst:369
msgid ""
"Variables used in the generator expression are evaluated lazily when the "
":meth:`~generator.__next__` method is called for the generator object (in"
" the same fashion as normal generators).  However, the iterable "
"expression in the leftmost :keyword:`!for` clause is immediately "
"evaluated, so that an error produced by it will be emitted at the point "
"where the generator expression is defined, rather than at the point where"
" the first value is retrieved. Subsequent :keyword:`!for` clauses and any"
" filter condition in the leftmost :keyword:`!for` clause cannot be "
"evaluated in the enclosing scope as they may depend on the values "
"obtained from the leftmost iterable. For example: ``(x*y for x in "
"range(10) for y in range(x, x+10))``."
msgstr ""

#: ../../reference/expressions.rst:380
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr ""

#: ../../reference/expressions.rst:383
msgid ""
"To avoid interfering with the expected operation of the generator "
"expression itself, ``yield`` and ``yield from`` expressions are "
"prohibited in the implicitly defined generator."
msgstr ""

#: ../../reference/expressions.rst:387
msgid ""
"If a generator expression contains either :keyword:`!async for` clauses "
"or :keyword:`await` expressions it is called an :dfn:`asynchronous "
"generator expression`.  An asynchronous generator expression returns a "
"new asynchronous generator object, which is an asynchronous iterator (see"
" :ref:`async-iterators`)."
msgstr ""

#: ../../reference/expressions.rst:393
msgid "Asynchronous generator expressions were introduced."
msgstr ""

#: ../../reference/expressions.rst:396
msgid ""
"Prior to Python 3.7, asynchronous generator expressions could only appear"
" in :keyword:`async def` coroutines.  Starting with 3.7, any function can"
" use asynchronous generator expressions."
msgstr ""

#: ../../reference/expressions.rst:408
msgid "Yield expressions"
msgstr ""

#: ../../reference/expressions.rst:420
msgid ""
"The yield expression is used when defining a :term:`generator` function "
"or an :term:`asynchronous generator` function and thus can only be used "
"in the body of a function definition.  Using a yield expression in a "
"function's body causes that function to be a generator, and using it in "
"an :keyword:`async def` function's body causes that coroutine function to"
" be an asynchronous generator. For example::"
msgstr ""

#: ../../reference/expressions.rst:433
msgid ""
"Due to their side effects on the containing scope, ``yield`` expressions "
"are not permitted as part of the implicitly defined scopes used to "
"implement comprehensions and generator expressions."
msgstr ""

#: ../../reference/expressions.rst:437
msgid ""
"Yield expressions prohibited in the implicitly nested scopes used to "
"implement comprehensions and generator expressions."
msgstr ""

#: ../../reference/expressions.rst:441
msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-"
"generator-functions`."
msgstr ""

#: ../../reference/expressions.rst:445
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first yield "
"expression, where it is suspended again, returning the value of "
":token:`expression_list` to the generator's caller.  By suspended, we "
"mean that all local state is retained, including the current bindings of "
"local variables, the instruction pointer, the internal evaluation stack, "
"and the state of any exception handling.  When the execution is resumed "
"by calling one of the generator's methods, the function can proceed "
"exactly as if the yield expression were just another external call.  The "
"value of the yield expression after resuming depends on the method which "
"resumed the execution.  If :meth:`~generator.__next__` is used (typically"
" via either a :keyword:`for` or the :func:`next` builtin) then the result"
" is :const:`None`.  Otherwise, if :meth:`~generator.send` is used, then "
"the result will be the value passed in to that method."
msgstr ""

#: ../../reference/expressions.rst:464
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it "
"yields; the control is always transferred to the generator's caller."
msgstr ""

#: ../../reference/expressions.rst:470
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If"
" the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's "
":meth:`~generator.close` method will be called, allowing any pending "
":keyword:`finally` clauses to execute."
msgstr ""

#: ../../reference/expressions.rst:479
msgid ""
"When ``yield from <expr>`` is used, the supplied expression must be an "
"iterable. The values produced by iterating that iterable are passed "
"directly to the caller of the current generator's methods. Any values "
"passed in with :meth:`~generator.send` and any exceptions passed in with "
":meth:`~generator.throw` are passed to the underlying iterator if it has "
"the appropriate methods.  If this is not the case, then "
":meth:`~generator.send` will raise :exc:`AttributeError` or "
":exc:`TypeError`, while :meth:`~generator.throw` will just raise the "
"passed in exception immediately."
msgstr ""

#: ../../reference/expressions.rst:488
msgid ""
"When the underlying iterator is complete, the "
":attr:`~StopIteration.value` attribute of the raised :exc:`StopIteration`"
" instance becomes the value of the yield expression. It can be either set"
" explicitly when raising :exc:`StopIteration`, or automatically when the "
"subiterator is a generator (by returning a value from the subgenerator)."
msgstr ""

#: ../../reference/expressions.rst:494
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr ""

#: ../../reference/expressions.rst:497
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr ""

#: ../../reference/expressions.rst:503
msgid ":pep:`255` - Simple Generators"
msgstr ""

#: ../../reference/expressions.rst:503
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""

#: ../../reference/expressions.rst:507
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ""

#: ../../reference/expressions.rst:506
msgid ""
"The proposal to enhance the API and syntax of generators, making them "
"usable as simple coroutines."
msgstr ""

#: ../../reference/expressions.rst:511
msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ""

#: ../../reference/expressions.rst:510
msgid ""
"The proposal to introduce the :token:`yield_from` syntax, making "
"delegation to subgenerators easy."
msgstr ""

#: ../../reference/expressions.rst:514
msgid ":pep:`525` - Asynchronous Generators"
msgstr ""

#: ../../reference/expressions.rst:514
msgid ""
"The proposal that expanded on :pep:`492` by adding generator capabilities"
" to coroutine functions."
msgstr ""

#: ../../reference/expressions.rst:521
msgid "Generator-iterator methods"
msgstr ""

#: ../../reference/expressions.rst:523
msgid ""
"This subsection describes the methods of a generator iterator.  They can "
"be used to control the execution of a generator function."
msgstr ""

#: ../../reference/expressions.rst:526
msgid ""
"Note that calling any of the generator methods below when the generator "
"is already executing raises a :exc:`ValueError` exception."
msgstr ""

#: ../../reference/expressions.rst:534
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a "
":meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next "
"yield expression, where the generator is suspended again, and the value "
"of the :token:`expression_list` is returned to :meth:`__next__`'s caller."
"  If the generator exits without yielding another value, a "
":exc:`StopIteration` exception is raised."
msgstr ""

#: ../../reference/expressions.rst:543
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop,"
" or by the built-in :func:`next` function."
msgstr ""

#: ../../reference/expressions.rst:549
msgid ""
"Resumes the execution and \"sends\" a value into the generator function."
"  The *value* argument becomes the result of the current yield "
"expression.  The :meth:`send` method returns the next value yielded by "
"the generator, or raises :exc:`StopIteration` if the generator exits "
"without yielding another value.  When :meth:`send` is called to start the"
" generator, it must be called with :const:`None` as the argument, because"
" there is no yield expression that could receive the value."
msgstr ""

#: ../../reference/expressions.rst:560
msgid ""
"Raises an exception of type ``type`` at the point where the generator was"
" paused, and returns the next value yielded by the generator function.  "
"If the generator exits without yielding another value, a "
":exc:`StopIteration` exception is raised.  If the generator function does"
" not catch the passed-in exception, or raises a different exception, then"
" that exception propagates to the caller."
msgstr ""

#: ../../reference/expressions.rst:571
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function "
"was paused.  If the generator function then exits gracefully, is already "
"closed, or raises :exc:`GeneratorExit` (by not catching the exception), "
"close returns to its caller.  If the generator yields a value, a "
":exc:`RuntimeError` is raised.  If the generator raises any other "
"exception, it is propagated to the caller.  :meth:`close` does nothing if"
" the generator has already exited due to an exception or normal exit."
msgstr ""

#: ../../reference/expressions.rst:582
msgid "Examples"
msgstr ""

#: ../../reference/expressions.rst:584
msgid ""
"Here is a simple example that demonstrates the behavior of generators and"
" generator functions::"
msgstr ""

#: ../../reference/expressions.rst:611
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""

#: ../../reference/expressions.rst:619
msgid ""
"The presence of a yield expression in a function or method defined using "
":keyword:`async def` further defines the function as an "
":term:`asynchronous generator` function."
msgstr ""

#: ../../reference/expressions.rst:623
msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That "
"object then controls the execution of the generator function. An "
"asynchronous generator object is typically used in an :keyword:`async "
"for` statement in a coroutine function analogously to how a generator "
"object would be used in a :keyword:`for` statement."
msgstr ""

#: ../../reference/expressions.rst:630
msgid ""
"Calling one of the asynchronous generator's methods returns an "
":term:`awaitable` object, and the execution starts when this object is "
"awaited on. At that time, the execution proceeds to the first yield "
"expression, where it is suspended again, returning the value of "
":token:`expression_list` to the awaiting coroutine. As with a generator, "
"suspension means that all local state is retained, including the current "
"bindings of local variables, the instruction pointer, the internal "
"evaluation stack, and the state of any exception handling.  When the "
"execution is resumed by awaiting on the next object returned by the "
"asynchronous generator's methods, the function can proceed exactly as if "
"the yield expression were just another external call. The value of the "
"yield expression after resuming depends on the method which resumed the "
"execution.  If :meth:`~agen.__anext__` is used then the result is "
":const:`None`. Otherwise, if :meth:`~agen.asend` is used, then the result"
" will be the value passed in to that method."
msgstr ""

#: ../../reference/expressions.rst:646
msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`!try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the "
"responsibility of the event loop or scheduler running the asynchronous "
"generator to call the asynchronous generator-iterator's "
":meth:`~agen.aclose` method and run the resulting coroutine object, thus "
"allowing any pending :keyword:`!finally` clauses to execute."
msgstr ""

#: ../../reference/expressions.rst:657
msgid ""
"To take care of finalization, an event loop should define a *finalizer* "
"function which takes an asynchronous generator-iterator and presumably "
"calls :meth:`~agen.aclose` and executes the coroutine. This  *finalizer* "
"may be registered by calling :func:`sys.set_asyncgen_hooks`. When first "
"iterated over, an asynchronous generator-iterator will store the "
"registered *finalizer* to be called upon finalization. For a reference "
"example of a *finalizer* method see the implementation of "
"``asyncio.Loop.shutdown_asyncgens`` in "
":source:`Lib/asyncio/base_events.py`."
msgstr ""

#: ../../reference/expressions.rst:666
msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr ""

#: ../../reference/expressions.rst:673
msgid "Asynchronous generator-iterator methods"
msgstr ""

#: ../../reference/expressions.rst:675
msgid ""
"This subsection describes the methods of an asynchronous generator "
"iterator, which are used to control the execution of a generator "
"function."
msgstr ""

#: ../../reference/expressions.rst:683
msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with an "
":meth:`~agen.__anext__` method, the current yield expression always "
"evaluates to :const:`None` in the returned awaitable, which when run will"
" continue to the next yield expression. The value of the "
":token:`expression_list` of the yield expression is the value of the "
":exc:`StopIteration` exception raised by the completing coroutine.  If "
"the asynchronous generator exits without yielding another value, the "
"awaitable instead raises a :exc:`StopAsyncIteration` exception, "
"signalling that the asynchronous iteration has completed."
msgstr ""

#: ../../reference/expressions.rst:695
msgid "This method is normally called implicitly by a :keyword:`async for` loop."
msgstr ""

#: ../../reference/expressions.rst:700
msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send()` method for "
"a generator, this \"sends\" a value into the asynchronous generator "
"function, and the *value* argument becomes the result of the current "
"yield expression. The awaitable returned by the :meth:`asend` method will"
" return the next value yielded by the generator as the value of the "
"raised :exc:`StopIteration`, or raises :exc:`StopAsyncIteration` if the "
"asynchronous generator exits without yielding another value.  When "
":meth:`asend` is called to start the asynchronous generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""

#: ../../reference/expressions.rst:715
msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the "
"point where the asynchronous generator was paused, and returns the next "
"value yielded by the generator function as the value of the raised "
":exc:`StopIteration` exception.  If the asynchronous generator exits "
"without yielding another value, a :exc:`StopAsyncIteration` exception is "
"raised by the awaitable. If the generator function does not catch the "
"passed-in exception, or raises a different exception, then when the "
"awaitable is run that exception propagates to the caller of the "
"awaitable."
msgstr ""

#: ../../reference/expressions.rst:730
msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into"
" the asynchronous generator function at the point where it was paused. If"
" the asynchronous generator function then exits gracefully, is already "
"closed, or raises :exc:`GeneratorExit` (by not catching the exception), "
"then the returned awaitable will raise a :exc:`StopIteration` exception. "
"Any further awaitables returned by subsequent calls to the asynchronous "
"generator will raise a :exc:`StopAsyncIteration` exception.  If the "
"asynchronous generator yields a value, a :exc:`RuntimeError` is raised by"
" the awaitable.  If the asynchronous generator raises any other "
"exception, it is propagated to the caller of the awaitable.  If the "
"asynchronous generator has already exited due to an exception or normal "
"exit, then further calls to :meth:`aclose` will return an awaitable that "
"does nothing."
msgstr ""

#: ../../reference/expressions.rst:746
msgid "Primaries"
msgstr ""

#: ../../reference/expressions.rst:750
msgid ""
"Primaries represent the most tightly bound operations of the language. "
"Their syntax is:"
msgstr ""

#: ../../reference/expressions.rst:760
msgid "Attribute references"
msgstr ""

#: ../../reference/expressions.rst:766
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""

#: ../../reference/expressions.rst:776
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce "
"the attribute whose name is the identifier.  This production can be "
"customized by overriding the :meth:`__getattr__` method.  If this "
"attribute is not available, the exception :exc:`AttributeError` is "
"raised.  Otherwise, the type and value of the object produced is "
"determined by the object.  Multiple evaluations of the same attribute "
"reference may yield different objects."
msgstr ""

#: ../../reference/expressions.rst:788
msgid "Subscriptions"
msgstr ""

#: ../../reference/expressions.rst:803
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr ""

#: ../../reference/expressions.rst:809
msgid ""
"The primary must evaluate to an object that supports subscription (lists "
"or dictionaries for example).  User-defined objects can support "
"subscription by defining a :meth:`__getitem__` method."
msgstr ""

#: ../../reference/expressions.rst:813
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription:"
msgstr ""

#: ../../reference/expressions.rst:815
msgid ""
"If the primary is a mapping, the expression list must evaluate to an "
"object whose value is one of the keys of the mapping, and the "
"subscription selects the value in the mapping that corresponds to that "
"key.  (The expression list is a tuple except if it has exactly one item.)"
msgstr ""

#: ../../reference/expressions.rst:820
msgid ""
"If the primary is a sequence, the expression list must evaluate to an "
"integer or a slice (as discussed in the following section)."
msgstr ""

#: ../../reference/expressions.rst:823
msgid ""
"The formal syntax makes no special provision for negative indices in "
"sequences; however, built-in sequences all provide a :meth:`__getitem__` "
"method that interprets negative indices by adding the length of the "
"sequence to the index (so that ``x[-1]`` selects the last item of ``x``)."
"  The resulting value must be a nonnegative integer less than the number "
"of items in the sequence, and the subscription selects the item whose "
"index is that value (counting from zero). Since the support for negative "
"indices and slicing occurs in the object's :meth:`__getitem__` method, "
"subclasses overriding this method will need to explicitly add that "
"support."
msgstr ""

#: ../../reference/expressions.rst:837
msgid ""
"A string's items are characters.  A character is not a separate data type"
" but a string of exactly one character."
msgstr ""

#: ../../reference/expressions.rst:844
msgid "Slicings"
msgstr ""

#: ../../reference/expressions.rst:858
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""

#: ../../reference/expressions.rst:871
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an"
" expression list also looks like a slice list, so any subscription can be"
" interpreted as a slicing.  Rather than further complicating the syntax, "
"this is disambiguated by defining that in this case the interpretation as"
" a subscription takes priority over the interpretation as a slicing (this"
" is the case if the slice list contains no proper slice)."
msgstr ""

#: ../../reference/expressions.rst:883
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed "
"(using the same :meth:`__getitem__` method as normal subscription) with a"
" key that is constructed from the slice list, as follows.  If the slice "
"list contains at least one comma, the key is a tuple containing the "
"conversion of the slice items; otherwise, the conversion of the lone "
"slice item is the key.  The conversion of a slice item that is an "
"expression is that expression.  The conversion of a proper slice is a "
"slice object (see section :ref:`types`) whose :attr:`~slice.start`, "
":attr:`~slice.stop` and :attr:`~slice.step` attributes are the values of "
"the expressions given as lower bound, upper bound and stride, "
"respectively, substituting ``None`` for missing expressions."
msgstr ""

#: ../../reference/expressions.rst:907
msgid "Calls"
msgstr ""

#: ../../reference/expressions.rst:909
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly"
" empty series of :term:`arguments <argument>`:"
msgstr ""

#: ../../reference/expressions.rst:926
msgid ""
"An optional trailing comma may be present after the positional and "
"keyword arguments but does not affect the semantics."
msgstr ""

#: ../../reference/expressions.rst:932
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods "
"of class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""

#: ../../reference/expressions.rst:940
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for "
"the formal parameters.  If there are N positional arguments, they are "
"placed in the first N slots.  Next, for each keyword argument, the "
"identifier is used to determine the corresponding slot (if the identifier"
" is the same as the first formal parameter name, the first slot is used, "
"and so on).  If the slot is already filled, a :exc:`TypeError` exception "
"is raised. Otherwise, the value of the argument is placed in the slot, "
"filling it (even if the expression is ``None``, it fills the slot).  When"
" all arguments have been processed, the slots that are still unfilled are"
" filled with the corresponding default value from the function "
"definition.  (Default values are calculated, once, when the function is "
"defined; thus, a mutable object such as a list or dictionary used as "
"default value will be shared by all calls that don't specify an argument "
"value for the corresponding slot; this should usually be avoided.)  If "
"there are any unfilled slots for which no default value is specified, a "
":exc:`TypeError` exception is raised.  Otherwise, the list of filled "
"slots is used as the argument list for the call."
msgstr ""

#: ../../reference/expressions.rst:960
msgid ""
"An implementation may provide built-in functions whose positional "
"parameters do not have names, even if they are 'named' for the purpose of"
" documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use "
":c:func:`PyArg_ParseTuple` to parse their arguments."
msgstr ""

#: ../../reference/expressions.rst:966
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or"
" an empty tuple if there were no excess positional arguments)."
msgstr ""

#: ../../reference/expressions.rst:972
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a"
" :exc:`TypeError` exception is raised, unless a formal parameter using "
"the syntax ``**identifier`` is present; in this case, that formal "
"parameter receives a dictionary containing the excess keyword arguments "
"(using the keywords as keys and the argument values as corresponding "
"values), or a (new) empty dictionary if there were no excess keyword "
"arguments."
msgstr ""

#: ../../reference/expressions.rst:983
msgid ""
"If the syntax ``*expression`` appears in the function call, "
"``expression`` must evaluate to an :term:`iterable`.  Elements from these"
" iterables are treated as if they were additional positional arguments.  "
"For the call ``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence "
"*y1*, ..., *yM*, this is equivalent to a call with M+4 positional "
"arguments *x1*, *x2*, *y1*, ..., *yM*, *x3*, *x4*."
msgstr ""

#: ../../reference/expressions.rst:990
msgid ""
"A consequence of this is that although the ``*expression`` syntax may "
"appear *after* explicit keyword arguments, it is processed *before* the "
"keyword arguments (and any ``**expression`` arguments -- see below).  "
"So::"
msgstr ""

#: ../../reference/expressions.rst:1006
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax "
"to be used in the same call, so in practice this confusion does not "
"arise."
msgstr ""

#: ../../reference/expressions.rst:1012
msgid ""
"If the syntax ``**expression`` appears in the function call, "
"``expression`` must evaluate to a :term:`mapping`, the contents of which "
"are treated as additional keyword arguments.  If a keyword is already "
"present (as an explicit keyword argument, or from another unpacking), a "
":exc:`TypeError` exception is raised."
msgstr ""

#: ../../reference/expressions.rst:1018
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""

#: ../../reference/expressions.rst:1021
msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, "
"positional arguments may follow iterable unpackings (``*``), and keyword "
"arguments may follow dictionary unpackings (``**``). Originally proposed "
"by :pep:`448`."
msgstr ""

#: ../../reference/expressions.rst:1027
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the "
"callable object."
msgstr ""

#: ../../reference/expressions.rst:1031
msgid "If it is---"
msgstr ""

#: ../../reference/expressions.rst:1044
msgid "a user-defined function:"
msgstr ""

#: ../../reference/expressions.rst:1040
msgid ""
"The code block for the function is executed, passing it the argument "
"list.  The first thing the code block will do is bind the formal "
"parameters to the arguments; this is described in section "
":ref:`function`.  When the code block executes a :keyword:`return` "
"statement, this specifies the return value of the function call."
msgstr ""

#: ../../reference/expressions.rst:1058
msgid "a built-in function or method:"
msgstr ""

#: ../../reference/expressions.rst:1057
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""

#: ../../reference/expressions.rst:1065
msgid "a class object:"
msgstr ""

#: ../../reference/expressions.rst:1065
msgid "A new instance of that class is returned."
msgstr ""

#: ../../reference/expressions.rst:1075
msgid "a class instance method:"
msgstr ""

#: ../../reference/expressions.rst:1073
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance "
"becomes the first argument."
msgstr ""

#: ../../reference/expressions.rst:1084
msgid "a class instance:"
msgstr ""

#: ../../reference/expressions.rst:1082
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the "
"same as if that method was called."
msgstr ""

#: ../../reference/expressions.rst:1090 ../../reference/expressions.rst:1855
msgid "Await expression"
msgstr ""

#: ../../reference/expressions.rst:1092
msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` "
"object. Can only be used inside a :term:`coroutine function`."
msgstr ""

#: ../../reference/expressions.rst:1104
msgid "The power operator"
msgstr ""

#: ../../reference/expressions.rst:1110
msgid ""
"The power operator binds more tightly than unary operators on its left; "
"it binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""

#: ../../reference/expressions.rst:1116
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""

#: ../../reference/expressions.rst:1120
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument "
"raised to the power of its right argument.  The numeric arguments are "
"first converted to a common type, and the result is of that type."
msgstr ""

#: ../../reference/expressions.rst:1125
msgid ""
"For int operands, the result has the same type as the operands unless the"
" second argument is negative; in that case, all arguments are converted "
"to float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""

#: ../../reference/expressions.rst:1130
msgid ""
"Raising ``0.0`` to a negative power results in a "
":exc:`ZeroDivisionError`. Raising a negative number to a fractional power"
" results in a :class:`complex` number. (In earlier versions it raised a "
":exc:`ValueError`.)"
msgstr ""

#: ../../reference/expressions.rst:1138
msgid "Unary arithmetic and bitwise operations"
msgstr ""

#: ../../reference/expressions.rst:1144
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""

#: ../../reference/expressions.rst:1155
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument."
msgstr ""

#: ../../reference/expressions.rst:1162
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr ""

#: ../../reference/expressions.rst:1168
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as "
"``-(x+1)``.  It only applies to integral numbers."
msgstr ""

#: ../../reference/expressions.rst:1174
msgid ""
"In all three cases, if the argument does not have the proper type, a "
":exc:`TypeError` exception is raised."
msgstr ""

#: ../../reference/expressions.rst:1181
msgid "Binary arithmetic operations"
msgstr ""

#: ../../reference/expressions.rst:1185
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric "
"types.  Apart from the power operator, there are only two levels, one for"
" multiplicative operators and one for additive operators:"
msgstr ""

#: ../../reference/expressions.rst:1200
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments."
"  The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers"
" are converted to a common type and then multiplied together.  In the "
"latter case, sequence repetition is performed; a negative repetition "
"factor yields an empty sequence."
msgstr ""

#: ../../reference/expressions.rst:1210
msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication."
"  No builtin Python types implement this operator."
msgstr ""

#: ../../reference/expressions.rst:1221
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted "
"to a common type. Division of integers yields a float, while floor "
"division of integers results in an integer; the result is that of "
"mathematical division with the 'floor' function applied to the result.  "
"Division by zero raises the :exc:`ZeroDivisionError` exception."
msgstr ""

#: ../../reference/expressions.rst:1232
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the"
" first argument by the second.  The numeric arguments are first converted"
" to a common type.  A zero right argument raises the "
":exc:`ZeroDivisionError` exception.  The arguments may be floating point "
"numbers, e.g., ``3.14%0.7`` equals ``0.34`` (since ``3.14`` equals "
"``4*0.7 + 0.34``.)  The modulo operator always yields a result with the "
"same sign as its second operand (or zero); the absolute value of the "
"result is strictly smaller than the absolute value of the second operand "
"[#]_."
msgstr ""

#: ../../reference/expressions.rst:1241
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == "
"(x//y, x%y)``. [#]_."
msgstr ""

#: ../../reference/expressions.rst:1246
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string"
" formatting (also known as interpolation).  The syntax for string "
"formatting is described in the Python Library Reference, section :ref"
":`old-string-formatting`."
msgstr ""

#: ../../reference/expressions.rst:1251
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""

#: ../../reference/expressions.rst:1260
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common type and"
" then added together. In the latter case, the sequences are concatenated."
msgstr ""

#: ../../reference/expressions.rst:1270
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments."
"  The numeric arguments are first converted to a common type."
msgstr ""

#: ../../reference/expressions.rst:1277
msgid "Shifting operations"
msgstr ""

#: ../../reference/expressions.rst:1284
msgid ""
"The shifting operations have lower priority than the arithmetic "
"operations:"
msgstr ""

#: ../../reference/expressions.rst:1289
msgid ""
"These operators accept integers as arguments.  They shift the first "
"argument to the left or right by the number of bits given by the second "
"argument."
msgstr ""

#: ../../reference/expressions.rst:1294
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  "
"A left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""

#: ../../reference/expressions.rst:1301
msgid "Binary bitwise operations"
msgstr ""

#: ../../reference/expressions.rst:1305
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""

#: ../../reference/expressions.rst:1316
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be"
" integers."
msgstr ""

#: ../../reference/expressions.rst:1324
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its "
"arguments, which must be integers."
msgstr ""

#: ../../reference/expressions.rst:1332
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, "
"which must be integers."
msgstr ""

#: ../../reference/expressions.rst:1339
msgid "Comparisons"
msgstr ""

#: ../../reference/expressions.rst:1351
msgid ""
"Unlike C, all comparison operations in Python have the same priority, "
"which is lower than that of any arithmetic, shifting or bitwise "
"operation.  Also unlike C, expressions like ``a < b < c`` have the "
"interpretation that is conventional in mathematics:"
msgstr ""

#: ../../reference/expressions.rst:1361
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr ""

#: ../../reference/expressions.rst:1365
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is "
"equivalent to ``x < y and y <= z``, except that ``y`` is evaluated only "
"once (but in both cases ``z`` is not evaluated at all when ``x < y`` is "
"found to be false)."
msgstr ""

#: ../../reference/expressions.rst:1369
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y "
"opN z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except "
"that each expression is evaluated at most once."
msgstr ""

#: ../../reference/expressions.rst:1374
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between "
"*a* and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though "
"perhaps not pretty)."
msgstr ""

#: ../../reference/expressions.rst:1379
msgid "Value comparisons"
msgstr ""

#: ../../reference/expressions.rst:1381
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare "
"the values of two objects.  The objects do not need to have the same "
"type."
msgstr ""

#: ../../reference/expressions.rst:1384
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to "
"type and identity).  The value of an object is a rather abstract notion "
"in Python: For example, there is no canonical access method for an "
"object's value.  Also, there is no requirement that the value of an "
"object should be constructed in a particular way, e.g. comprised of all "
"its data attributes. Comparison operators implement a particular notion "
"of what the value of an object is.  One can think of them as defining the"
" value of an object indirectly, by means of their comparison "
"implementation."
msgstr ""

#: ../../reference/expressions.rst:1393
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, "
"they inherit the default comparison behavior from :class:`object`.  Types"
" can customize their comparison behavior by implementing :dfn:`rich "
"comparison methods` like :meth:`__lt__`, described in "
":ref:`customization`."
msgstr ""

#: ../../reference/expressions.rst:1399
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based"
" on the identity of the objects.  Hence, equality comparison of instances"
" with the same identity results in equality, and equality comparison of "
"instances with different identities results in inequality.  A motivation "
"for this default behavior is the desire that all objects should be "
"reflexive (i.e. ``x is y`` implies ``x == y``)."
msgstr ""

#: ../../reference/expressions.rst:1406
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this "
"default behavior is the lack of a similar invariant as for equality."
msgstr ""

#: ../../reference/expressions.rst:1410
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types"
" will need that have a sensible definition of object value and value-"
"based equality.  Such types will need to customize their comparison "
"behavior, and in fact, a number of built-in types have done that."
msgstr ""

#: ../../reference/expressions.rst:1416
msgid ""
"The following list describes the comparison behavior of the most "
"important built-in types."
msgstr ""

#: ../../reference/expressions.rst:1419
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the "
"standard library types :class:`fractions.Fraction` and "
":class:`decimal.Decimal` can be compared within and across their types, "
"with the restriction that complex numbers do not support order "
"comparison.  Within the limits of the types involved, they compare "
"mathematically (algorithmically) correct without loss of precision."
msgstr ""

#: ../../reference/expressions.rst:1426
msgid ""
"The not-a-number values ``float('NaN')`` and ``decimal.Decimal('NaN')`` "
"are special.  Any ordered comparison of a number to a not-a-number value "
"is false. A counter-intuitive implication is that not-a-number values are"
" not equal to themselves.  For example, if ``x = float('NaN')``, ``3 < "
"x``, ``x < 3`` and ``x == x`` are all false, while ``x != x`` is true.  "
"This behavior is compliant with IEEE 754."
msgstr ""

#: ../../reference/expressions.rst:1433
msgid ""
"``None`` and ``NotImplemented`` are singletons.  :PEP:`8` advises that "
"comparisons for singletons should always be done with ``is`` or ``is "
"not``, never the equality operators."
msgstr ""

#: ../../reference/expressions.rst:1437
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can "
"be compared within and across their types.  They compare "
"lexicographically using the numeric values of their elements."
msgstr ""

#: ../../reference/expressions.rst:1441
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function "
":func:`ord`) of their characters. [#]_"
msgstr ""

#: ../../reference/expressions.rst:1445
msgid "Strings and binary sequences cannot be directly compared."
msgstr ""

#: ../../reference/expressions.rst:1447
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`)"
" can be compared only within each of their types, with the restriction "
"that ranges do not support order comparison.  Equality comparison across "
"these types results in inequality, and ordering comparison across these "
"types raises :exc:`TypeError`."
msgstr ""

#: ../../reference/expressions.rst:1453
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements.  The built-in containers typically assume identical objects are"
" equal to themselves.  That lets them bypass equality tests for identical"
" objects to improve performance and to maintain their internal "
"invariants."
msgstr ""

#: ../../reference/expressions.rst:1458
msgid "Lexicographical comparison between built-in collections works as follows:"
msgstr ""

#: ../../reference/expressions.rst:1460
msgid ""
"For two collections to compare equal, they must be of the same type, have"
" the same length, and each pair of corresponding elements must compare "
"equal (for example, ``[1,2] == (1,2)`` is false because the type is not "
"the same)."
msgstr ""

#: ../../reference/expressions.rst:1465
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""

#: ../../reference/expressions.rst:1471
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they "
"have equal `(key, value)` pairs. Equality comparison of the keys and "
"values enforces reflexivity."
msgstr ""

#: ../../reference/expressions.rst:1475
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise "
":exc:`TypeError`."
msgstr ""

#: ../../reference/expressions.rst:1477
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""

#: ../../reference/expressions.rst:1480
msgid ""
"They define order comparison operators to mean subset and superset tests."
"  Those relations do not define total orderings (for example, the two "
"sets ``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, "
"nor supersets of one another).  Accordingly, sets are not appropriate "
"arguments for functions which depend on total ordering (for example, "
":func:`min`, :func:`max`, and :func:`sorted` produce undefined results "
"given a list of sets as inputs)."
msgstr ""

#: ../../reference/expressions.rst:1488
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr ""

#: ../../reference/expressions.rst:1490
msgid ""
"Most other built-in types have no comparison methods implemented, so they"
" inherit the default comparison behavior."
msgstr ""

#: ../../reference/expressions.rst:1493
msgid ""
"User-defined classes that customize their comparison behavior should "
"follow some consistency rules, if possible:"
msgstr ""

#: ../../reference/expressions.rst:1496
msgid ""
"Equality comparison should be reflexive. In other words, identical "
"objects should compare equal:"
msgstr ""

#: ../../reference/expressions.rst:1499
msgid "``x is y`` implies ``x == y``"
msgstr ""

#: ../../reference/expressions.rst:1501
msgid ""
"Comparison should be symmetric. In other words, the following expressions"
" should have the same result:"
msgstr ""

#: ../../reference/expressions.rst:1504
msgid "``x == y`` and ``y == x``"
msgstr ""

#: ../../reference/expressions.rst:1506
msgid "``x != y`` and ``y != x``"
msgstr ""

#: ../../reference/expressions.rst:1508
msgid "``x < y`` and ``y > x``"
msgstr ""

#: ../../reference/expressions.rst:1510
msgid "``x <= y`` and ``y >= x``"
msgstr ""

#: ../../reference/expressions.rst:1512
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""

#: ../../reference/expressions.rst:1515
msgid "``x > y and y > z`` implies ``x > z``"
msgstr ""

#: ../../reference/expressions.rst:1517
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr ""

#: ../../reference/expressions.rst:1519
msgid ""
"Inverse comparison should result in the boolean negation. In other words,"
" the following expressions should have the same result:"
msgstr ""

#: ../../reference/expressions.rst:1522
msgid "``x == y`` and ``not x != y``"
msgstr ""

#: ../../reference/expressions.rst:1524
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr ""

#: ../../reference/expressions.rst:1526
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr ""

#: ../../reference/expressions.rst:1528
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the "
":func:`~functools.total_ordering` decorator."
msgstr ""

#: ../../reference/expressions.rst:1532
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that "
"are equal should either have the same hash value, or be marked as "
"unhashable."
msgstr ""

#: ../../reference/expressions.rst:1536
msgid ""
"Python does not enforce these consistency rules. In fact, the "
"not-a-number values are an example for not following these rules."
msgstr ""

#: ../../reference/expressions.rst:1545
msgid "Membership test operations"
msgstr ""

#: ../../reference/expressions.rst:1547
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  "
"``x in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False``"
" otherwise. ``x not in s`` returns the negation of ``x in s``.  All "
"built-in sequences and set types support this as well as dictionary, for "
"which :keyword:`!in` tests whether the dictionary has a given key. For "
"container types such as list, tuple, set, frozenset, dict, or "
"collections.deque, the expression ``x in y`` is equivalent to ``any(x is "
"e or x == e for e in y)``."
msgstr ""

#: ../../reference/expressions.rst:1555
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x*"
" is a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  "
"Empty strings are always considered to be a substring of any other "
"string, so ``\"\" in \"abc\"`` will return ``True``."
msgstr ""

#: ../../reference/expressions.rst:1560
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, "
"``x in y`` returns ``True`` if ``y.__contains__(x)`` returns a true "
"value, and ``False`` otherwise."
msgstr ""

#: ../../reference/expressions.rst:1564
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z``, for "
"which the expression ``x is z or x == z`` is true, is produced while "
"iterating over ``y``. If an exception is raised during the iteration, it "
"is as if :keyword:`in` raised that exception."
msgstr ""

#: ../../reference/expressions.rst:1570
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines "
":meth:`__getitem__`, ``x in y`` is ``True`` if and only if there is a "
"non-negative integer index *i* such that ``x is y[i] or x == y[i]``, and "
"no lower integer index raises the :exc:`IndexError` exception.  (If any "
"other exception is raised, it is as if :keyword:`in` raised that "
"exception)."
msgstr ""

#: ../../reference/expressions.rst:1582
msgid ""
"The operator :keyword:`not in` is defined to have the inverse truth value"
" of :keyword:`in`."
msgstr ""

#: ../../reference/expressions.rst:1595
msgid "Identity comparisons"
msgstr ""

#: ../../reference/expressions.rst:1597
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for an object's "
"identity: ``x is y`` is true if and only if *x* and *y* are the same "
"object.  An Object's identity is determined using the :meth:`id` "
"function.  ``x is not y`` yields the inverse truth value. [#]_"
msgstr ""

#: ../../reference/expressions.rst:1609
msgid "Boolean operations"
msgstr ""

#: ../../reference/expressions.rst:1620
msgid ""
"In the context of Boolean operations, and also when expressions are used "
"by control flow statements, the following values are interpreted as "
"false: ``False``, ``None``, numeric zero of all types, and empty strings "
"and containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""

#: ../../reference/expressions.rst:1629
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""

#: ../../reference/expressions.rst:1634
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its "
"value is returned; otherwise, *y* is evaluated and the resulting value is"
" returned."
msgstr ""

#: ../../reference/expressions.rst:1639
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is "
"returned."
msgstr ""

#: ../../reference/expressions.rst:1642
msgid ""
"Note that neither :keyword:`and` nor :keyword:`or` restrict the value and"
" type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string"
" that should be replaced by a default value if it is empty, the "
"expression ``s or 'foo'`` yields the desired value.  Because "
":keyword:`not` has to create a new value, it returns a boolean value "
"regardless of the type of its argument (for example, ``not 'foo'`` "
"produces ``False`` rather than ``''``.)"
msgstr ""

#: ../../reference/expressions.rst:1652
msgid "Assignment expressions"
msgstr ""

#: ../../reference/expressions.rst:1657
msgid ""
"An assignment expression (sometimes also called a \"named expression\" or"
" \"walrus\") assigns an :token:`expression` to an :token:`identifier`, "
"while also returning the value of the :token:`expression`."
msgstr ""

#: ../../reference/expressions.rst:1661
msgid "One common use case is when handling matched regular expressions:"
msgstr ""

#: ../../reference/expressions.rst:1668
msgid "Or, when processing a file stream in chunks:"
msgstr ""

#: ../../reference/expressions.rst:1675
msgid "See :pep:`572` for more details about assignment expressions."
msgstr ""

#: ../../reference/expressions.rst:1682
msgid "Conditional expressions"
msgstr ""

#: ../../reference/expressions.rst:1695
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have "
"the lowest priority of all Python operations."
msgstr ""

#: ../../reference/expressions.rst:1698
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* "
"rather than *x*. If *C* is true, *x* is evaluated and its value is "
"returned; otherwise, *y* is evaluated and its value is returned."
msgstr ""

#: ../../reference/expressions.rst:1702
msgid "See :pep:`308` for more details about conditional expressions."
msgstr ""

#: ../../reference/expressions.rst:1709
msgid "Lambdas"
msgstr ""

#: ../../reference/expressions.rst:1721
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` "
"yields a function object.  The unnamed object behaves like a function "
"object defined with:"
msgstr ""

#: ../../reference/expressions.rst:1730
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that"
" functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""

#: ../../reference/expressions.rst:1738
msgid "Expression lists"
msgstr ""

#: ../../reference/expressions.rst:1752
msgid ""
"Except when part of a list or set display, an expression list containing "
"at least one comma yields a tuple.  The length of the tuple is the number"
" of expressions in the list.  The expressions are evaluated from left to "
"right."
msgstr ""

#: ../../reference/expressions.rst:1761
msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be"
" an :term:`iterable`.  The iterable is expanded into a sequence of items,"
" which are included in the new tuple, list, or set, at the site of the "
"unpacking."
msgstr ""

#: ../../reference/expressions.rst:1766
msgid "Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr ""

#: ../../reference/expressions.rst:1771
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the "
"value of that expression. (To create an empty tuple, use an empty pair of"
" parentheses: ``()``.)"
msgstr ""

#: ../../reference/expressions.rst:1781
msgid "Evaluation order"
msgstr ""

#: ../../reference/expressions.rst:1785
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the "
"left-hand side."
msgstr ""

#: ../../reference/expressions.rst:1788
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""

#: ../../reference/expressions.rst:1802
msgid "Operator precedence"
msgstr ""

#: ../../reference/expressions.rst:1807
msgid ""
"The following table summarizes the operator precedence in Python, from "
"lowest precedence (least binding) to highest precedence (most binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is"
" explicitly given, operators are binary.  Operators in the same box group"
" left to right (except for exponentiation, which groups from right to "
"left)."
msgstr ""

#: ../../reference/expressions.rst:1813
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the"
" same precedence and have a left-to-right chaining feature as described "
"in the :ref:`comparisons` section."
msgstr ""

#: ../../reference/expressions.rst:1819
msgid "Operator"
msgstr ""

#: ../../reference/expressions.rst:1819
msgid "Description"
msgstr ""

#: ../../reference/expressions.rst:1821
msgid "``:=``"
msgstr ""

#: ../../reference/expressions.rst:1821
msgid "Assignment expression"
msgstr ""

#: ../../reference/expressions.rst:1823
msgid ":keyword:`lambda`"
msgstr ""

#: ../../reference/expressions.rst:1823
msgid "Lambda expression"
msgstr ""

#: ../../reference/expressions.rst:1825
msgid ":keyword:`if <if_expr>` -- :keyword:`!else`"
msgstr ""

#: ../../reference/expressions.rst:1825
msgid "Conditional expression"
msgstr ""

#: ../../reference/expressions.rst:1827
msgid ":keyword:`or`"
msgstr ""

#: ../../reference/expressions.rst:1827
msgid "Boolean OR"
msgstr ""

#: ../../reference/expressions.rst:1829
msgid ":keyword:`and`"
msgstr ""

#: ../../reference/expressions.rst:1829
msgid "Boolean AND"
msgstr ""

#: ../../reference/expressions.rst:1831
msgid ":keyword:`not` ``x``"
msgstr ""

#: ../../reference/expressions.rst:1831
msgid "Boolean NOT"
msgstr ""

#: ../../reference/expressions.rst:1833
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, "
"``<``, ``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""

#: ../../reference/expressions.rst:1833
msgid "Comparisons, including membership tests and identity tests"
msgstr ""

#: ../../reference/expressions.rst:1837
msgid "``|``"
msgstr ""

#: ../../reference/expressions.rst:1837
msgid "Bitwise OR"
msgstr ""

#: ../../reference/expressions.rst:1839
msgid "``^``"
msgstr ""

#: ../../reference/expressions.rst:1839
msgid "Bitwise XOR"
msgstr ""

#: ../../reference/expressions.rst:1841
msgid "``&``"
msgstr ""

#: ../../reference/expressions.rst:1841
msgid "Bitwise AND"
msgstr ""

#: ../../reference/expressions.rst:1843
msgid "``<<``, ``>>``"
msgstr ""

#: ../../reference/expressions.rst:1843
msgid "Shifts"
msgstr ""

#: ../../reference/expressions.rst:1845
msgid "``+``, ``-``"
msgstr ""

#: ../../reference/expressions.rst:1845
msgid "Addition and subtraction"
msgstr ""

#: ../../reference/expressions.rst:1847
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr ""

#: ../../reference/expressions.rst:1847
msgid ""
"Multiplication, matrix multiplication, division, floor division, "
"remainder [#]_"
msgstr ""

#: ../../reference/expressions.rst:1851
msgid "``+x``, ``-x``, ``~x``"
msgstr ""

#: ../../reference/expressions.rst:1851
msgid "Positive, negative, bitwise NOT"
msgstr ""

#: ../../reference/expressions.rst:1853
msgid "``**``"
msgstr ""

#: ../../reference/expressions.rst:1853
msgid "Exponentiation [#]_"
msgstr ""

#: ../../reference/expressions.rst:1855
msgid ":keyword:`await` ``x``"
msgstr ""

#: ../../reference/expressions.rst:1857
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr ""

#: ../../reference/expressions.rst:1857
msgid "Subscription, slicing, call, attribute reference"
msgstr ""

#: ../../reference/expressions.rst:1860
msgid "``(expressions...)``,"
msgstr ""

#: ../../reference/expressions.rst:1862
msgid "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"
msgstr ""

#: ../../reference/expressions.rst:1860
msgid ""
"Binding or parenthesized expression, list display, dictionary display, "
"set display"
msgstr ""

#: ../../reference/expressions.rst:1870
#, python-format
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not"
" be true numerically due to roundoff.  For example, and assuming a "
"platform on which a Python float is an IEEE 754 double-precision number, "
"in order that ``-1e-100 % 1e100`` have the same sign as ``1e100``, the "
"computed result is ``-1e-100 + 1e100``, which is numerically exactly "
"equal to ``1e100``.  The function :func:`math.fmod` returns a result "
"whose sign matches the sign of the first argument instead, and so returns"
" ``-1e-100`` in this case. Which approach is more appropriate depends on "
"the application."
msgstr ""

#: ../../reference/expressions.rst:1879
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for "
"``x//y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such "
"cases, Python returns the latter result, in order to preserve that "
"``divmod(x,y)[0] * y + x % y`` be very close to ``x``."
msgstr ""

#: ../../reference/expressions.rst:1884
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. "
"U+0041) and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\")."
" While most abstract characters in Unicode are only represented using one"
" code point, there is a number of abstract characters that can in "
"addition be represented using a sequence of more than one code point.  "
"For example, the abstract character \"LATIN CAPITAL LETTER C WITH "
"CEDILLA\" can be represented as a single :dfn:`precomposed character` at "
"code position U+00C7, or as a sequence of a :dfn:`base character` at code"
" position U+0043 (LATIN CAPITAL LETTER C), followed by a :dfn:`combining "
"character` at code position U+0327 (COMBINING CEDILLA)."
msgstr ""

#: ../../reference/expressions.rst:1895
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, "
"``\"\\u00C7\" == \"\\u0043\\u0327\"`` is ``False``, even though both "
"strings represent the same abstract character \"LATIN CAPITAL LETTER C "
"WITH CEDILLA\"."
msgstr ""

#: ../../reference/expressions.rst:1900
msgid ""
"To compare strings at the level of abstract characters (that is, in a way"
" intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""

#: ../../reference/expressions.rst:1903
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature "
"of descriptors, you may notice seemingly unusual behaviour in certain "
"uses of the :keyword:`is` operator, like those involving comparisons "
"between instance methods, or constants.  Check their documentation for "
"more info."
msgstr ""

#: ../../reference/expressions.rst:1908
msgid ""
"The ``%`` operator is also used for string formatting; the same "
"precedence applies."
msgstr ""

#: ../../reference/expressions.rst:1911
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or "
"bitwise unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""

#: ../../reference/grammar.rst:2
msgid "Full Grammar specification"
msgstr ""

#: ../../reference/grammar.rst:4
msgid ""
"This is the full Python grammar, as it is read by the parser generator "
"and used to parse Python source files:"
msgstr ""

#: ../../reference/import.rst:6
msgid "The import system"
msgstr ""

#: ../../reference/import.rst:10
msgid ""
"Python code in one :term:`module` gains access to the code in another "
"module by the process of :term:`importing` it.  The :keyword:`import` "
"statement is the most common way of invoking the import machinery, but it"
" is not the only way.  Functions such as :func:`importlib.import_module` "
"and built-in :func:`__import__` can also be used to invoke the import "
"machinery."
msgstr ""

#: ../../reference/import.rst:16
msgid ""
"The :keyword:`import` statement combines two operations; it searches for "
"the named module, then it binds the results of that search to a name in "
"the local scope.  The search operation of the :keyword:`!import` "
"statement is defined as a call to the :func:`__import__` function, with "
"the appropriate arguments. The return value of :func:`__import__` is used"
" to perform the name binding operation of the :keyword:`!import` "
"statement.  See the :keyword:`!import` statement for the exact details of"
" that name binding operation."
msgstr ""

#: ../../reference/import.rst:25
msgid ""
"A direct call to :func:`__import__` performs only the module search and, "
"if found, the module creation operation.  While certain side-effects may "
"occur, such as the importing of parent packages, and the updating of "
"various caches (including :data:`sys.modules`), only the "
":keyword:`import` statement performs a name binding operation."
msgstr ""

#: ../../reference/import.rst:31
msgid ""
"When an :keyword:`import` statement is executed, the standard builtin "
":func:`__import__` function is called. Other mechanisms for invoking the "
"import system (such as :func:`importlib.import_module`) may choose to "
"bypass :func:`__import__` and use their own solutions to implement import"
" semantics."
msgstr ""

#: ../../reference/import.rst:36
msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the "
"named module cannot be found, a :exc:`ModuleNotFoundError` is raised.  "
"Python implements various strategies to search for the named module when "
"the import machinery is invoked.  These strategies can be modified and "
"extended by using various hooks described in the sections below."
msgstr ""

#: ../../reference/import.rst:43
msgid ""
"The import system has been updated to fully implement the second phase of"
" :pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, "
"native namespace package support has been implemented (see :pep:`420`)."
msgstr ""

#: ../../reference/import.rst:51
msgid ":mod:`importlib`"
msgstr ""

#: ../../reference/import.rst:53
msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking "
"the import machinery.  Refer to the :mod:`importlib` library "
"documentation for additional detail."
msgstr ""

#: ../../reference/import.rst:62
msgid "Packages"
msgstr ""

#: ../../reference/import.rst:67
msgid ""
"Python has only one type of module object, and all modules are of this "
"type, regardless of whether the module is implemented in Python, C, or "
"something else.  To help organize modules and provide a naming hierarchy,"
" Python has a concept of :term:`packages <package>`."
msgstr ""

#: ../../reference/import.rst:72
msgid ""
"You can think of packages as the directories on a file system and modules"
" as files within directories, but don't take this analogy too literally "
"since packages and modules need not originate from the file system.  For "
"the purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are "
"organized hierarchically, and packages may themselves contain "
"subpackages, as well as regular modules."
msgstr ""

#: ../../reference/import.rst:80
msgid ""
"It's important to keep in mind that all packages are modules, but not all"
" modules are packages.  Or put another way, packages are just a special "
"kind of module.  Specifically, any module that contains a ``__path__`` "
"attribute is considered a package."
msgstr ""

#: ../../reference/import.rst:85
msgid ""
"All modules have a name.  Subpackage names are separated from their "
"parent package name by dots, akin to Python's standard attribute access "
"syntax.  Thus you might have a module called :mod:`sys` and a package "
"called :mod:`email`, which in turn has a subpackage called "
":mod:`email.mime` and a module within that subpackage called "
":mod:`email.mime.text`."
msgstr ""

#: ../../reference/import.rst:93
msgid "Regular packages"
msgstr ""

#: ../../reference/import.rst:98
msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and "
"earlier. A regular package is typically implemented as a directory "
"containing an ``__init__.py`` file.  When a regular package is imported, "
"this ``__init__.py`` file is implicitly executed, and the objects it "
"defines are bound to names in the package's namespace.  The "
"``__init__.py`` file can contain the same Python code that any other "
"module can contain, and Python will add some additional attributes to the"
" module when it is imported."
msgstr ""

#: ../../reference/import.rst:108
msgid ""
"For example, the following file system layout defines a top level "
"``parent`` package with three subpackages::"
msgstr ""

#: ../../reference/import.rst:120
msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` "
"and ``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and "
"``parent/three/__init__.py`` respectively."
msgstr ""

#: ../../reference/import.rst:127
msgid "Namespace packages"
msgstr ""

#: ../../reference/import.rst:133
msgid ""
"A namespace package is a composite of various :term:`portions <portion>`,"
" where each portion contributes a subpackage to the parent package.  "
"Portions may reside in different locations on the file system.  Portions "
"may also be found in zip files, on the network, or anywhere else that "
"Python searches during import.  Namespace packages may or may not "
"correspond directly to objects on the file system; they may be virtual "
"modules that have no concrete representation."
msgstr ""

#: ../../reference/import.rst:141
msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will "
"automatically perform a new search for package portions on the next "
"import attempt within that package if the path of their parent package "
"(or :data:`sys.path` for a top level package) changes."
msgstr ""

#: ../../reference/import.rst:147
msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In "
"fact, there may be multiple ``parent`` directories found during import "
"search, where each one is provided by a different portion.  Thus "
"``parent/one`` may not be physically located next to ``parent/two``.  In "
"this case, Python will create a namespace package for the top-level "
"``parent`` package whenever it or one of its subpackages is imported."
msgstr ""

#: ../../reference/import.rst:154
msgid "See also :pep:`420` for the namespace package specification."
msgstr ""

#: ../../reference/import.rst:158
msgid "Searching"
msgstr ""

#: ../../reference/import.rst:160
msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from "
"the parameters to the :func:`importlib.import_module` or "
":func:`__import__` functions."
msgstr ""

#: ../../reference/import.rst:166
msgid ""
"This name will be used in various phases of the import search, and it may"
" be the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, "
"Python first tries to import ``foo``, then ``foo.bar``, and finally "
"``foo.bar.baz``. If any of the intermediate imports fail, a "
":exc:`ModuleNotFoundError` is raised."
msgstr ""

#: ../../reference/import.rst:173
msgid "The module cache"
msgstr ""

#: ../../reference/import.rst:178
msgid ""
"The first place checked during import search is :data:`sys.modules`.  "
"This mapping serves as a cache of all modules that have been previously "
"imported, including the intermediate paths.  So if ``foo.bar.baz`` was "
"previously imported, :data:`sys.modules` will contain entries for "
"``foo``, ``foo.bar``, and ``foo.bar.baz``.  Each key will have as its "
"value the corresponding module object."
msgstr ""

#: ../../reference/import.rst:185
msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if"
" present, the associated value is the module satisfying the import, and "
"the process completes.  However, if the value is ``None``, then a "
":exc:`ModuleNotFoundError` is raised.  If the module name is missing, "
"Python will continue searching for the module."
msgstr ""

#: ../../reference/import.rst:191
msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it "
"will invalidate the cache entry for the named module, causing Python to "
"search anew for the named module upon its next import. The key can also "
"be assigned to ``None``, forcing the next import of the module to result "
"in a :exc:`ModuleNotFoundError`."
msgstr ""

#: ../../reference/import.rst:198
msgid ""
"Beware though, as if you keep a reference to the module object, "
"invalidate its cache entry in :data:`sys.modules`, and then re-import the"
" named module, the two module objects will *not* be the same. By "
"contrast, :func:`importlib.reload` will reuse the *same* module object, "
"and simply reinitialise the module contents by rerunning the module's "
"code."
msgstr ""

#: ../../reference/import.rst:208
msgid "Finders and loaders"
msgstr ""

#: ../../reference/import.rst:215
msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and "
":term:`loaders <loader>`. A finder's job is to determine whether it can "
"find the named module using whatever strategy it knows about. Objects "
"that implement both of these interfaces are referred to as "
":term:`importers <importer>` - they return themselves when they find that"
" they can load the requested module."
msgstr ""

#: ../../reference/import.rst:223
msgid ""
"Python includes a number of default finders and importers.  The first one"
" knows how to locate built-in modules, and the second knows how to locate"
" frozen modules.  A third default finder searches an :term:`import path` "
"for modules.  The :term:`import path` is a list of locations that may "
"name file system paths or zip files.  It can also be extended to search "
"for any locatable resource, such as those identified by URLs."
msgstr ""

#: ../../reference/import.rst:230
msgid ""
"The import machinery is extensible, so new finders can be added to extend"
" the range and scope of module searching."
msgstr ""

#: ../../reference/import.rst:233
msgid ""
"Finders do not actually load modules.  If they can find the named module,"
" they return a :dfn:`module spec`, an encapsulation of the module's "
"import-related information, which the import machinery then uses when "
"loading the module."
msgstr ""

#: ../../reference/import.rst:237
msgid ""
"The following sections describe the protocol for finders and loaders in "
"more detail, including how you can create and register new ones to extend"
" the import machinery."
msgstr ""

#: ../../reference/import.rst:241
msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>`"
" directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""

#: ../../reference/import.rst:247
msgid "Import hooks"
msgstr ""

#: ../../reference/import.rst:257
msgid ""
"The import machinery is designed to be extensible; the primary mechanism "
"for this are the *import hooks*.  There are two types of import hooks: "
"*meta hooks* and *import path hooks*."
msgstr ""

#: ../../reference/import.rst:261
msgid ""
"Meta hooks are called at the start of import processing, before any other"
" import processing has occurred, other than :data:`sys.modules` cache "
"look up. This allows meta hooks to override :data:`sys.path` processing, "
"frozen modules, or even built-in modules.  Meta hooks are registered by "
"adding new finder objects to :data:`sys.meta_path`, as described below."
msgstr ""

#: ../../reference/import.rst:267
msgid ""
"Import path hooks are called as part of :data:`sys.path` (or "
"``package.__path__``) processing, at the point where their associated "
"path item is encountered.  Import path hooks are registered by adding new"
" callables to :data:`sys.path_hooks` as described below."
msgstr ""

#: ../../reference/import.rst:274
msgid "The meta path"
msgstr ""

#: ../../reference/import.rst:280
msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder"
" objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method "
"called :meth:`~importlib.abc.MetaPathFinder.find_spec()` which takes "
"three arguments: a name, an import path, and (optionally) a target "
"module.  The meta path finder can use any strategy it wants to determine "
"whether it can handle the named module or not."
msgstr ""

#: ../../reference/import.rst:289
msgid ""
"If the meta path finder knows how to handle the named module, it returns "
"a spec object.  If it cannot handle the named module, it returns "
"``None``.  If :data:`sys.meta_path` processing reaches the end of its "
"list without returning a spec, then a :exc:`ModuleNotFoundError` is "
"raised.  Any other exceptions raised are simply propagated up, aborting "
"the import process."
msgstr ""

#: ../../reference/import.rst:295
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec()` method of meta path"
" finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``."
" The second argument is the path entries to use for the module search.  "
"For top-level modules, the second argument is ``None``, but for "
"submodules or subpackages, the second argument is the value of the parent"
" package's ``__path__`` attribute. If the appropriate ``__path__`` "
"attribute cannot be accessed, a :exc:`ModuleNotFoundError` is raised.  "
"The third argument is an existing module object that will be the target "
"of loading later. The import system passes in a target module only during"
" reload."
msgstr ""

#: ../../reference/import.rst:306
msgid ""
"The meta path may be traversed multiple times for a single import "
"request. For example, assuming none of the modules involved has already "
"been cached, importing ``foo.bar.baz`` will first perform a top level "
"import, calling ``mpf.find_spec(\"foo\", None, None)`` on each meta path "
"finder (``mpf``). After ``foo`` has been imported, ``foo.bar`` will be "
"imported by traversing the meta path a second time, calling "
"``mpf.find_spec(\"foo.bar\", foo.__path__, None)``. Once ``foo.bar`` has "
"been imported, the final traversal will call "
"``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."
msgstr ""

#: ../../reference/import.rst:316
msgid ""
"Some meta path finders only support top level imports. These importers "
"will always return ``None`` when anything other than ``None`` is passed "
"as the second argument."
msgstr ""

#: ../../reference/import.rst:320
msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one "
"that knows how to import built-in modules, one that knows how to import "
"frozen modules, and one that knows how to import modules from an "
":term:`import path` (i.e. the :term:`path based finder`)."
msgstr ""

#: ../../reference/import.rst:325
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`~importlib.abc.MetaPathFinder.find_module`, which"
" is now deprecated.  While it will continue to work without change, the "
"import machinery will try it only if the finder does not implement "
"``find_spec()``."
msgstr ""

#: ../../reference/import.rst:334
msgid "Loading"
msgstr ""

#: ../../reference/import.rst:336
msgid ""
"If and when a module spec is found, the import machinery will use it (and"
" the loader it contains) when loading the module.  Here is an "
"approximation of what happens during the loading portion of import::"
msgstr ""

#: ../../reference/import.rst:370
msgid "Note the following details:"
msgstr ""

#: ../../reference/import.rst:372
msgid ""
"If there is an existing module object with the given name in "
":data:`sys.modules`, import will have already returned it."
msgstr ""

#: ../../reference/import.rst:375
msgid ""
"The module will exist in :data:`sys.modules` before the loader executes "
"the module code.  This is crucial because the module code may (directly "
"or indirectly) import itself; adding it to :data:`sys.modules` beforehand"
" prevents unbounded recursion in the worst case and multiple loading in "
"the best."
msgstr ""

#: ../../reference/import.rst:381
msgid ""
"If loading fails, the failing module -- and only the failing module -- "
"gets removed from :data:`sys.modules`.  Any module already in the "
":data:`sys.modules` cache, and any module that was successfully loaded as"
" a side-effect, must remain in the cache.  This contrasts with reloading "
"where even the failing module is left in :data:`sys.modules`."
msgstr ""

#: ../../reference/import.rst:387
msgid ""
"After the module is created but before execution, the import machinery "
"sets the import-related module attributes (\"_init_module_attrs\" in the "
"pseudo-code example above), as summarized in a :ref:`later section "
"<import-mod-attrs>`."
msgstr ""

#: ../../reference/import.rst:392
msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader,"
" which gets to decide what gets populated and how."
msgstr ""

#: ../../reference/import.rst:396
msgid ""
"The module created during loading and passed to exec_module() may not be "
"the one returned at the end of import [#fnlo]_."
msgstr ""

#: ../../reference/import.rst:399
msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the "
":meth:`importlib.abc.Loader.load_module` method."
msgstr ""

#: ../../reference/import.rst:405
msgid "Loaders"
msgstr ""

#: ../../reference/import.rst:407
msgid ""
"Module loaders provide the critical function of loading: module "
"execution. The import machinery calls the "
":meth:`importlib.abc.Loader.exec_module` method with a single argument, "
"the module object to execute.  Any value returned from "
":meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""

#: ../../reference/import.rst:412
msgid "Loaders must satisfy the following requirements:"
msgstr ""

#: ../../reference/import.rst:414
msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's "
"code in the module's global name space (``module.__dict__``)."
msgstr ""

#: ../../reference/import.rst:418
msgid ""
"If the loader cannot execute the module, it should raise an "
":exc:`ImportError`, although any other exception raised during "
":meth:`~importlib.abc.Loader.exec_module` will be propagated."
msgstr ""

#: ../../reference/import.rst:422
msgid ""
"In many cases, the finder and loader can be the same object; in such "
"cases the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would "
"just return a spec with the loader set to ``self``."
msgstr ""

#: ../../reference/import.rst:426
msgid ""
"Module loaders may opt in to creating the module object during loading by"
" implementing a :meth:`~importlib.abc.Loader.create_module` method. It "
"takes one argument, the module spec, and returns the new module object to"
" use during loading.  ``create_module()`` does not need to set any "
"attributes on the module object.  If the method returns ``None``, the "
"import machinery will create the new module itself."
msgstr ""

#: ../../reference/import.rst:433
msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr ""

#: ../../reference/import.rst:436
msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by "
":meth:`~importlib.abc.Loader.exec_module` and the import machinery "
"assumed all the boilerplate responsibilities of loading."
msgstr ""

#: ../../reference/import.rst:441
msgid ""
"For compatibility with existing loaders, the import machinery will use "
"the ``load_module()`` method of loaders if it exists and the loader does "
"not also implement ``exec_module()``.  However, ``load_module()`` has "
"been deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""

#: ../../reference/import.rst:446
msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All "
"the same constraints apply, with some additional clarification:"
msgstr ""

#: ../../reference/import.rst:450
msgid ""
"If there is an existing module object with the given name in "
":data:`sys.modules`, the loader must use that existing module. "
"(Otherwise, :func:`importlib.reload` will not work correctly.)  If the "
"named module does not exist in :data:`sys.modules`, the loader must "
"create a new module object and add it to :data:`sys.modules`."
msgstr ""

#: ../../reference/import.rst:456
msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes"
" the module code, to prevent unbounded recursion or multiple loading."
msgstr ""

#: ../../reference/import.rst:460
msgid ""
"If loading fails, the loader must remove any modules it has inserted into"
" :data:`sys.modules`, but it must remove **only** the failing module(s), "
"and only if the loader itself has loaded the module(s) explicitly."
msgstr ""

#: ../../reference/import.rst:465
msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined "
"but ``create_module()`` is not."
msgstr ""

#: ../../reference/import.rst:469
msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""

#: ../../reference/import.rst:474
msgid "Submodules"
msgstr ""

#: ../../reference/import.rst:476
msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, "
"the ``import`` or ``import-from`` statements, or built-in "
"``__import__()``) a binding is placed in the parent module's namespace to"
" the submodule object. For example, if package ``spam`` has a submodule "
"``foo``, after importing ``spam.foo``, ``spam`` will have an attribute "
"``foo`` which is bound to the submodule.  Let's say you have the "
"following directory structure::"
msgstr ""

#: ../../reference/import.rst:488
msgid "and ``spam/__init__.py`` has the following lines in it::"
msgstr ""

#: ../../reference/import.rst:493
msgid ""
"then executing the following puts a name binding to ``foo`` and ``bar`` "
"in the ``spam`` module::"
msgstr ""

#: ../../reference/import.rst:502
msgid ""
"Given Python's familiar name binding rules this might seem surprising, "
"but it's actually a fundamental feature of the import system.  The "
"invariant holding is that if you have ``sys.modules['spam']`` and "
"``sys.modules['spam.foo']`` (as you would after the above import), the "
"latter must appear as the ``foo`` attribute of the former."
msgstr ""

#: ../../reference/import.rst:509
msgid "Module spec"
msgstr ""

#: ../../reference/import.rst:511
msgid ""
"The import machinery uses a variety of information about each module "
"during import, especially before loading.  Most of the information is "
"common to all modules.  The purpose of a module's spec is to encapsulate "
"this import-related information on a per-module basis."
msgstr ""

#: ../../reference/import.rst:516
msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec "
"and the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas "
"without a module spec the loader had that responsibility."
msgstr ""

#: ../../reference/import.rst:522
msgid ""
"The module's spec is exposed as the ``__spec__`` attribute on a module "
"object. See :class:`~importlib.machinery.ModuleSpec` for details on the "
"contents of the module spec."
msgstr ""

#: ../../reference/import.rst:531
msgid "Import-related module attributes"
msgstr ""

#: ../../reference/import.rst:533
msgid ""
"The import machinery fills in these attributes on each module object "
"during loading, based on the module's spec, before the loader executes "
"the module."
msgstr ""

#: ../../reference/import.rst:539
msgid ""
"The ``__name__`` attribute must be set to the fully-qualified name of the"
" module.  This name is used to uniquely identify the module in the import"
" system."
msgstr ""

#: ../../reference/import.rst:545
msgid ""
"The ``__loader__`` attribute must be set to the loader object that the "
"import machinery used when loading the module.  This is mostly for "
"introspection, but can be used for additional loader-specific "
"functionality, for example getting data associated with a loader."
msgstr ""

#: ../../reference/import.rst:552
msgid ""
"The module's ``__package__`` attribute must be set.  Its value must be a "
"string, but it can be the same value as its ``__name__``.  When the "
"module is a package, its ``__package__`` value should be set to its "
"``__name__``.  When the module is not a package, ``__package__`` should "
"be set to the empty string for top-level modules, or for submodules, to "
"the parent package's name.  See :pep:`366` for further details."
msgstr ""

#: ../../reference/import.rst:560
msgid ""
"This attribute is used instead of ``__name__`` to calculate explicit "
"relative imports for main modules, as defined in :pep:`366`. It is "
"expected to have the same value as ``__spec__.parent``."
msgstr ""

#: ../../reference/import.rst:564
msgid ""
"The value of ``__package__`` is expected to be the same as "
"``__spec__.parent``."
msgstr ""

#: ../../reference/import.rst:570
msgid ""
"The ``__spec__`` attribute must be set to the module spec that was used "
"when importing the module. Setting ``__spec__`` appropriately applies "
"equally to :ref:`modules initialized during interpreter startup "
"<programs>`.  The one exception is ``__main__``, where ``__spec__`` is "
":ref:`set to None in some cases <main_spec>`."
msgstr ""

#: ../../reference/import.rst:576
msgid ""
"When ``__package__`` is not defined, ``__spec__.parent`` is used as a "
"fallback."
msgstr ""

#: ../../reference/import.rst:581
msgid ""
"``__spec__.parent`` is used as a fallback when ``__package__`` is not "
"defined."
msgstr ""

#: ../../reference/import.rst:587
msgid ""
"If the module is a package (either regular or namespace), the module "
"object's ``__path__`` attribute must be set.  The value must be iterable,"
" but may be empty if ``__path__`` has no further significance. If "
"``__path__`` is not empty, it must produce strings when iterated over. "
"More details on the semantics of ``__path__`` are given :ref:`below "
"<package-path-rules>`."
msgstr ""

#: ../../reference/import.rst:594
msgid "Non-package modules should not have a ``__path__`` attribute."
msgstr ""

#: ../../reference/import.rst:599
msgid ""
"``__file__`` is optional. If set, this attribute's value must be a "
"string.  The import system may opt to leave ``__file__`` unset if it has "
"no semantic meaning (e.g. a module loaded from a database)."
msgstr ""

#: ../../reference/import.rst:603
msgid ""
"If ``__file__`` is set, it may also be appropriate to set the "
"``__cached__`` attribute which is the path to any compiled version of the"
" code (e.g. byte-compiled file). The file does not need to exist to set "
"this attribute; the path can simply point to where the compiled file "
"would exist (see :pep:`3147`)."
msgstr ""

#: ../../reference/import.rst:609
msgid ""
"It is also appropriate to set ``__cached__`` when ``__file__`` is not "
"set.  However, that scenario is quite atypical.  Ultimately, the loader "
"is what makes use of ``__file__`` and/or ``__cached__``.  So if a loader "
"can load from a cached module but otherwise does not load from a file, "
"that atypical scenario may be appropriate."
msgstr ""

#: ../../reference/import.rst:618
msgid "module.__path__"
msgstr ""

#: ../../reference/import.rst:620
msgid "By definition, if a module has a ``__path__`` attribute, it is a package."
msgstr ""

#: ../../reference/import.rst:622
msgid ""
"A package's ``__path__`` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as "
":data:`sys.path`, i.e. providing a list of locations to search for "
"modules during import. However, ``__path__`` is typically much more "
"constrained than :data:`sys.path`."
msgstr ""

#: ../../reference/import.rst:628
msgid ""
"``__path__`` must be an iterable of strings, but it may be empty. The "
"same rules used for :data:`sys.path` also apply to a package's "
"``__path__``, and :data:`sys.path_hooks` (described below) are consulted "
"when traversing a package's ``__path__``."
msgstr ""

#: ../../reference/import.rst:633
msgid ""
"A package's ``__init__.py`` file may set or alter the package's "
"``__path__`` attribute, and this was typically the way namespace packages"
" were implemented prior to :pep:`420`.  With the adoption of :pep:`420`, "
"namespace packages no longer need to supply ``__init__.py`` files "
"containing only ``__path__`` manipulation code; the import machinery "
"automatically sets ``__path__`` correctly for the namespace package."
msgstr ""

#: ../../reference/import.rst:641
msgid "Module reprs"
msgstr ""

#: ../../reference/import.rst:643
msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""

#: ../../reference/import.rst:647
msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to"
" generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available "
"on the module.  It will try to use the ``module.__name__``, "
"``module.__file__``, and ``module.__loader__`` as input into the repr, "
"with defaults for whatever information is missing."
msgstr ""

#: ../../reference/import.rst:654
msgid "Here are the exact rules used:"
msgstr ""

#: ../../reference/import.rst:656
msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec "
"is used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""

#: ../../reference/import.rst:660
msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr ""

#: ../../reference/import.rst:663
msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is "
"not ``None``, then the loader's repr is used as part of the module's "
"repr."
msgstr ""

#: ../../reference/import.rst:666
msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr ""

#: ../../reference/import.rst:668
msgid ""
"Use of :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` "
"has been deprecated and the module spec is now used by the import "
"machinery to generate a module repr."
msgstr ""

#: ../../reference/import.rst:673
msgid ""
"For backward compatibility with Python 3.3, the module repr will be "
"generated by calling the loader's "
":meth:`~importlib.abc.Loader.module_repr` method, if defined, before "
"trying either approach described above.  However, the method is "
"deprecated."
msgstr ""

#: ../../reference/import.rst:681
msgid "Cached bytecode invalidation"
msgstr ""

#: ../../reference/import.rst:683
msgid ""
"Before Python loads cached bytecode from a ``.pyc`` file, it checks "
"whether the cache is up-to-date with the source ``.py`` file. By default,"
" Python does this by storing the source's last-modified timestamp and "
"size in the cache file when writing it. At runtime, the import system "
"then validates the cache file by checking the stored metadata in the "
"cache file against the source's metadata."
msgstr ""

#: ../../reference/import.rst:690
msgid ""
"Python also supports \"hash-based\" cache files, which store a hash of "
"the source file's contents rather than its metadata. There are two "
"variants of hash-based ``.pyc`` files: checked and unchecked. For checked"
" hash-based ``.pyc`` files, Python validates the cache file by hashing "
"the source file and comparing the resulting hash with the hash in the "
"cache file. If a checked hash-based cache file is found to be invalid, "
"Python regenerates it and writes a new checked hash-based cache file. For"
" unchecked hash-based ``.pyc`` files, Python simply assumes the cache "
"file is valid if it exists. Hash-based ``.pyc`` files validation behavior"
" may be overridden with the :option:`--check-hash-based-pycs` flag."
msgstr ""

#: ../../reference/import.rst:701
msgid ""
"Added hash-based ``.pyc`` files. Previously, Python only supported "
"timestamp-based invalidation of bytecode caches."
msgstr ""

#: ../../reference/import.rst:707
msgid "The Path Based Finder"
msgstr ""

#: ../../reference/import.rst:712
msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` "
"(:class:`~importlib.machinery.PathFinder`), searches an :term:`import "
"path`, which contains a list of :term:`path entries <path entry>`.  Each "
"path entry names a location to search for modules."
msgstr ""

#: ../../reference/import.rst:718
msgid ""
"The path based finder itself doesn't know how to import anything. "
"Instead, it traverses the individual path entries, associating each of "
"them with a path entry finder that knows how to handle that particular "
"kind of path."
msgstr ""

#: ../../reference/import.rst:722
msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and"
" shared libraries (e.g. ``.so`` files). When supported by the "
":mod:`zipimport` module in the standard library, the default path entry "
"finders also handle loading all of these file types (other than shared "
"libraries) from zipfiles."
msgstr ""

#: ../../reference/import.rst:729
msgid ""
"Path entries need not be limited to file system locations.  They can "
"refer to URLs, database queries, or any other location that can be "
"specified as a string."
msgstr ""

#: ../../reference/import.rst:733
msgid ""
"The path based finder provides additional hooks and protocols so that you"
" can extend and customize the types of searchable path entries.  For "
"example, if you wanted to support path entries as network URLs, you could"
" write a hook that implements HTTP semantics to find modules on the web."
"  This hook (a callable) would return a :term:`path entry finder` "
"supporting the protocol described below, which was then used to get a "
"loader for the module from the web."
msgstr ""

#: ../../reference/import.rst:741
msgid ""
"A word of warning: this section and the previous both use the term "
"*finder*, distinguishing between them by using the terms :term:`meta path"
" finder` and :term:`path entry finder`.  These two types of finders are "
"very similar, support similar protocols, and function in similar ways "
"during the import process, but it's important to keep in mind that they "
"are subtly different. In particular, meta path finders operate at the "
"beginning of the import process, as keyed off the :data:`sys.meta_path` "
"traversal."
msgstr ""

#: ../../reference/import.rst:749
msgid ""
"By contrast, path entry finders are in a sense an implementation detail "
"of the path based finder, and in fact, if the path based finder were to "
"be removed from :data:`sys.meta_path`, none of the path entry finder "
"semantics would be invoked."
msgstr ""

#: ../../reference/import.rst:756
msgid "Path entry finders"
msgstr ""

#: ../../reference/import.rst:764
msgid ""
"The :term:`path based finder` is responsible for finding and loading "
"Python modules and packages whose location is specified with a string "
":term:`path entry`.  Most path entries name locations in the file system,"
" but they need not be limited to this."
msgstr ""

#: ../../reference/import.rst:769
msgid ""
"As a meta path finder, the :term:`path based finder` implements the "
":meth:`~importlib.abc.MetaPathFinder.find_spec` protocol previously "
"described, however it exposes additional hooks that can be used to "
"customize how modules are found and loaded from the :term:`import path`."
msgstr ""

#: ../../reference/import.rst:774
msgid ""
"Three variables are used by the :term:`path based finder`, "
":data:`sys.path`, :data:`sys.path_hooks` and "
":data:`sys.path_importer_cache`.  The ``__path__`` attributes on package "
"objects are also used.  These provide additional ways that the import "
"machinery can be customized."
msgstr ""

#: ../../reference/import.rst:779
msgid ""
":data:`sys.path` contains a list of strings providing search locations "
"for modules and packages.  It is initialized from the :data:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on "
"the file system, zip files, and potentially other \"locations\" (see the "
":mod:`site` module) that should be searched for modules, such as URLs, or"
" database queries.  Only strings and bytes should be present on "
":data:`sys.path`; all other data types are ignored.  The encoding of "
"bytes entries is determined by the individual :term:`path entry finders "
"<path entry finder>`."
msgstr ""

#: ../../reference/import.rst:790
msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the "
"import machinery begins the :term:`import path` search by calling the "
"path based finder's :meth:`~importlib.machinery.PathFinder.find_spec` "
"method as described previously.  When the ``path`` argument to "
":meth:`~importlib.machinery.PathFinder.find_spec` is given, it will be a "
"list of string paths to traverse - typically a package's ``__path__`` "
"attribute for an import within that package.  If the ``path`` argument is"
" ``None``, this indicates a top level import and :data:`sys.path` is "
"used."
msgstr ""

#: ../../reference/import.rst:799
msgid ""
"The path based finder iterates over every entry in the search path, and "
"for each of these, looks for an appropriate :term:`path entry finder` "
"(:class:`~importlib.abc.PathEntryFinder`) for the path entry.  Because "
"this can be an expensive operation (e.g. there may be `stat()` call "
"overheads for this search), the path based finder maintains a cache "
"mapping path entries to path entry finders.  This cache is maintained in "
":data:`sys.path_importer_cache` (despite the name, this cache actually "
"stores finder objects rather than being limited to :term:`importer` "
"objects). In this way, the expensive search for a particular :term:`path "
"entry` location's :term:`path entry finder` need only be done once.  User"
" code is free to remove cache entries from "
":data:`sys.path_importer_cache` forcing the path based finder to perform "
"the path entry search again [#fnpic]_."
msgstr ""

#: ../../reference/import.rst:812
msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the "
":term:`path entry hooks <path entry hook>` in this list is called with a "
"single argument, the path entry to be searched.  This callable may either"
" return a :term:`path entry finder` that can handle the path entry, or it"
" may raise :exc:`ImportError`.  An :exc:`ImportError` is used by the path"
" based finder to signal that the hook cannot find a :term:`path entry "
"finder` for that :term:`path entry`.  The exception is ignored and "
":term:`import path` iteration continues.  The hook should expect either a"
" string or bytes object; the encoding of bytes objects is up to the hook "
"(e.g. it may be a file system encoding, UTF-8, or something else), and if"
" the hook cannot decode the argument, it should raise :exc:`ImportError`."
msgstr ""

#: ../../reference/import.rst:826
msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry "
"finder` being returned, then the path based finder's "
":meth:`~importlib.machinery.PathFinder.find_spec` method will store "
"``None`` in :data:`sys.path_importer_cache` (to indicate that there is no"
" finder for this path entry) and return ``None``, indicating that this "
":term:`meta path finder` could not find the module."
msgstr ""

#: ../../reference/import.rst:833
msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path "
"entry hook` callables on :data:`sys.path_hooks`, then the following "
"protocol is used to ask the finder for a module spec, which is then used "
"when loading the module."
msgstr ""

#: ../../reference/import.rst:838
msgid ""
"The current working directory -- denoted by an empty string -- is handled"
" slightly differently from other entries on :data:`sys.path`. First, if "
"the current working directory is found to not exist, no value is stored "
"in :data:`sys.path_importer_cache`. Second, the value for the current "
"working directory is looked up fresh for each module lookup. Third, the "
"path used for :data:`sys.path_importer_cache` and returned by "
":meth:`importlib.machinery.PathFinder.find_spec` will be the actual "
"current working directory and not the empty string."
msgstr ""

#: ../../reference/import.rst:848
msgid "Path entry finder protocol"
msgstr ""

#: ../../reference/import.rst:850
msgid ""
"In order to support imports of modules and initialized packages and also "
"to contribute portions to namespace packages, path entry finders must "
"implement the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""

#: ../../reference/import.rst:854
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two arguments: the"
" fully qualified name of the module being imported, and the (optional) "
"target module.  ``find_spec()`` returns a fully populated spec for the "
"module. This spec will always have \"loader\" set (with one exception)."
msgstr ""

#: ../../reference/import.rst:859
msgid ""
"To indicate to the import machinery that the spec represents a namespace "
":term:`portion`, the path entry finder sets "
"\"submodule_search_locations\" to a list containing the portion."
msgstr ""

#: ../../reference/import.rst:863
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced "
":meth:`~importlib.abc.PathEntryFinder.find_loader` and "
":meth:`~importlib.abc.PathEntryFinder.find_module`, both of which are now"
" deprecated, but will be used if ``find_spec()`` is not defined."
msgstr ""

#: ../../reference/import.rst:869
msgid ""
"Older path entry finders may implement one of these two deprecated "
"methods instead of ``find_spec()``.  The methods are still respected for "
"the sake of backward compatibility.  However, if ``find_spec()`` is "
"implemented on the path entry finder, the legacy methods are ignored."
msgstr ""

#: ../../reference/import.rst:874
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` takes one argument, "
"the fully qualified name of the module being imported.  ``find_loader()``"
" returns a 2-tuple where the first item is the loader and the second item"
" is a namespace :term:`portion`."
msgstr ""

#: ../../reference/import.rst:879
msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path "
"entry finder ``find_module()`` methods are never called with a ``path`` "
"argument (they are expected to record the appropriate path information "
"from the initial call to the path hook)."
msgstr ""

#: ../../reference/import.rst:886
msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it "
"does not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a "
"path entry finder, the import system will always call ``find_loader()`` "
"in preference to ``find_module()``."
msgstr ""

#: ../../reference/import.rst:894
msgid "Replacing the standard import system"
msgstr ""

#: ../../reference/import.rst:896
msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""

#: ../../reference/import.rst:900
msgid ""
"If it is acceptable to only alter the behaviour of import statements "
"without affecting other APIs that access the import system, then "
"replacing the builtin :func:`__import__` function may be sufficient. This"
" technique may also be employed at the module level to only alter the "
"behaviour of import statements within that module."
msgstr ""

#: ../../reference/import.rst:906
msgid ""
"To selectively prevent the import of some modules from a hook early on "
"the meta path (rather than disabling the standard import system "
"entirely), it is sufficient to raise :exc:`ModuleNotFoundError` directly "
"from :meth:`~importlib.abc.MetaPathFinder.find_spec` instead of returning"
" ``None``. The latter indicates that the meta path search should "
"continue, while raising an exception terminates it immediately."
msgstr ""

#: ../../reference/import.rst:916
msgid "Package Relative Imports"
msgstr ""

#: ../../reference/import.rst:918
msgid ""
"Relative imports use leading dots. A single leading dot indicates a "
"relative import, starting with the current package. Two or more leading "
"dots indicate a relative import to the parent(s) of the current package, "
"one level per dot after the first. For example, given the following "
"package layout::"
msgstr ""

#: ../../reference/import.rst:934
msgid ""
"In either ``subpackage1/moduleX.py`` or ``subpackage1/__init__.py``, the "
"following are valid relative imports::"
msgstr ""

#: ../../reference/import.rst:944
msgid ""
"Absolute imports may use either the ``import <>`` or ``from <> import "
"<>`` syntax, but relative imports may only use the second form; the "
"reason for this is that::"
msgstr ""

#: ../../reference/import.rst:950
msgid ""
"should expose ``XXX.YYY.ZZZ`` as a usable expression, but .moduleY is not"
" a valid expression."
msgstr ""

#: ../../reference/import.rst:955
msgid "Special considerations for __main__"
msgstr ""

#: ../../reference/import.rst:957
msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is"
" directly initialized at interpreter startup, much like :mod:`sys` and "
":mod:`builtins`.  However, unlike those two, it doesn't strictly qualify "
"as a built-in module.  This is because the manner in which ``__main__`` "
"is initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""

#: ../../reference/import.rst:968
msgid "__main__.__spec__"
msgstr ""

#: ../../reference/import.rst:970
msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` "
"gets set appropriately or to ``None``."
msgstr ""

#: ../../reference/import.rst:973
msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set "
"to the module spec of the corresponding module or package. ``__spec__`` "
"is also populated when the ``__main__`` module is loaded as part of "
"executing a directory, zipfile or other :data:`sys.path` entry."
msgstr ""

#: ../../reference/import.rst:978
msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` "
"``__main__.__spec__`` is set to ``None``, as the code used to populate "
"the :mod:`__main__` does not correspond directly with an importable "
"module:"
msgstr ""

#: ../../reference/import.rst:982
msgid "interactive prompt"
msgstr ""

#: ../../reference/import.rst:983
msgid ":option:`-c` option"
msgstr ""

#: ../../reference/import.rst:984
msgid "running from stdin"
msgstr ""

#: ../../reference/import.rst:985
msgid "running directly from a source or bytecode file"
msgstr ""

#: ../../reference/import.rst:987
msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, "
"*even if* the file could technically be imported directly as a module "
"instead. Use the :option:`-m` switch if valid module metadata is desired "
"in :mod:`__main__`."
msgstr ""

#: ../../reference/import.rst:992
msgid ""
"Note also that even when ``__main__`` corresponds with an importable "
"module and ``__main__.__spec__`` is set accordingly, they're still "
"considered *distinct* modules. This is due to the fact that blocks "
"guarded by ``if __name__ == \"__main__\":`` checks only execute when the "
"module is used to populate the ``__main__`` namespace, and not during "
"normal import."
msgstr ""

#: ../../reference/import.rst:1000
msgid "Open issues"
msgstr ""

#: ../../reference/import.rst:1002
msgid "XXX It would be really nice to have a diagram."
msgstr ""

#: ../../reference/import.rst:1004
msgid ""
"XXX * (import_machinery.rst) how about a section devoted just to the "
"attributes of modules and packages, perhaps expanding upon or supplanting"
" the related entries in the data model reference page?"
msgstr ""

#: ../../reference/import.rst:1008
msgid ""
"XXX runpy, pkgutil, et al in the library manual should all get \"See "
"Also\" links at the top pointing to the new import system section."
msgstr ""

#: ../../reference/import.rst:1011
msgid ""
"XXX Add more explanation regarding the different ways in which "
"``__main__`` is initialized?"
msgstr ""

#: ../../reference/import.rst:1014
msgid ""
"XXX Add more info on ``__main__`` quirks/pitfalls (i.e. copy from "
":pep:`395`)."
msgstr ""

#: ../../reference/import.rst:1019
msgid "References"
msgstr ""

#: ../../reference/import.rst:1021
msgid ""
"The import machinery has evolved considerably since Python's early days."
"  The original `specification for packages "
"<https://www.python.org/doc/essays/packages/>`_ is still available to "
"read, although some details have changed since the writing of that "
"document."
msgstr ""

#: ../../reference/import.rst:1026
msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with"
" subsequent extension in :pep:`420`."
msgstr ""

#: ../../reference/import.rst:1029
msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`find_loader` protocol "
"as an alternative to :meth:`find_module`."
msgstr ""

#: ../../reference/import.rst:1033
msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""

#: ../../reference/import.rst:1036
msgid ""
":pep:`328` introduced absolute and explicit relative imports and "
"initially proposed ``__name__`` for semantics :pep:`366` would eventually"
" specify for ``__package__``."
msgstr ""

#: ../../reference/import.rst:1040
msgid ":pep:`338` defines executing modules as scripts."
msgstr ""

#: ../../reference/import.rst:1042
msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the "
"deprecation of several APIs in the import system and also addition of new"
" methods to finders and loaders."
msgstr ""

#: ../../reference/import.rst:1050
msgid "See :class:`types.ModuleType`."
msgstr ""

#: ../../reference/import.rst:1052
msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in "
":data:`sys.modules`.  The indirect effect of this is that an imported "
"module may replace itself in :data:`sys.modules`.  This is "
"implementation-specific behavior that is not guaranteed to work in other "
"Python implementations."
msgstr ""

#: ../../reference/import.rst:1059
msgid ""
"In legacy code, it is possible to find instances of "
":class:`imp.NullImporter` in the :data:`sys.path_importer_cache`.  It is "
"recommended that code be changed to use ``None`` instead.  See "
":ref:`portingpythoncode` for more details."
msgstr ""

#: ../../reference/index.rst:5
msgid "The Python Language Reference"
msgstr ""

#: ../../reference/index.rst:7
msgid ""
"This reference manual describes the syntax and \"core semantics\" of the "
"language. It is terse, but attempts to be exact and complete. The "
"semantics of non-essential built-in object types and of the built-in "
"functions and modules are described in :ref:`library-index`. For an "
"informal introduction to the language, see :ref:`tutorial-index`. For C "
"or C++ programmers, two additional manuals exist: :ref:`extending-index` "
"describes the high-level picture of how to write a Python extension "
"module, and the :ref:`c-api-index` describes the interfaces available to "
"C/C++ programmers in detail."
msgstr ""

#: ../../reference/introduction.rst:6
msgid "Introduction"
msgstr ""

#: ../../reference/introduction.rst:8
msgid ""
"This reference manual describes the Python programming language. It is "
"not intended as a tutorial."
msgstr ""

#: ../../reference/introduction.rst:11
msgid ""
"While I am trying to be as precise as possible, I chose to use English "
"rather than formal specifications for everything except syntax and "
"lexical analysis. This should make the document more understandable to "
"the average reader, but will leave room for ambiguities. Consequently, if"
" you were coming from Mars and tried to re-implement Python from this "
"document alone, you might have to guess things and in fact you would "
"probably end up implementing quite a different language. On the other "
"hand, if you are using Python and wonder what the precise rules about a "
"particular area of the language are, you should definitely be able to "
"find them here. If you would like to see a more formal definition of the "
"language, maybe you could volunteer your time --- or invent a cloning "
"machine :-)."
msgstr ""

#: ../../reference/introduction.rst:23
msgid ""
"It is dangerous to add too many implementation details to a language "
"reference document --- the implementation may change, and other "
"implementations of the same language may work differently.  On the other "
"hand, CPython is the one Python implementation in widespread use "
"(although alternate implementations continue to gain support), and its "
"particular quirks are sometimes worth being mentioned, especially where "
"the implementation imposes additional limitations. Therefore, you'll find"
" short \"implementation notes\" sprinkled throughout the text."
msgstr ""

#: ../../reference/introduction.rst:32
msgid ""
"Every Python implementation comes with a number of built-in and standard "
"modules.  These are documented in :ref:`library-index`.  A few built-in "
"modules are mentioned when they interact in a significant way with the "
"language definition."
msgstr ""

#: ../../reference/introduction.rst:41
msgid "Alternate Implementations"
msgstr ""

#: ../../reference/introduction.rst:43
msgid ""
"Though there is one Python implementation which is by far the most "
"popular, there are some alternate implementations which are of particular"
" interest to different audiences."
msgstr ""

#: ../../reference/introduction.rst:47
msgid "Known implementations include:"
msgstr ""

#: ../../reference/introduction.rst:51
msgid "CPython"
msgstr ""

#: ../../reference/introduction.rst:50
msgid ""
"This is the original and most-maintained implementation of Python, "
"written in C. New language features generally appear here first."
msgstr ""

#: ../../reference/introduction.rst:57
msgid "Jython"
msgstr ""

#: ../../reference/introduction.rst:54
msgid ""
"Python implemented in Java.  This implementation can be used as a "
"scripting language for Java applications, or can be used to create "
"applications using the Java class libraries.  It is also often used to "
"create tests for Java libraries. More information can be found at `the "
"Jython website <http://www.jython.org/>`_."
msgstr ""

#: ../../reference/introduction.rst:63
msgid "Python for .NET"
msgstr ""

#: ../../reference/introduction.rst:60
msgid ""
"This implementation actually uses the CPython implementation, but is a "
"managed .NET application and makes .NET libraries available.  It was "
"created by Brian Lloyd.  For more information, see the `Python for .NET "
"home page <https://pythonnet.github.io/>`_."
msgstr ""

#: ../../reference/introduction.rst:69
msgid "IronPython"
msgstr ""

#: ../../reference/introduction.rst:66
msgid ""
"An alternate Python for .NET.  Unlike Python.NET, this is a complete "
"Python implementation that generates IL, and compiles Python code "
"directly to .NET assemblies.  It was created by Jim Hugunin, the original"
" creator of Jython.  For more information, see `the IronPython website "
"<http://ironpython.net/>`_."
msgstr ""

#: ../../reference/introduction.rst:77
msgid "PyPy"
msgstr ""

#: ../../reference/introduction.rst:72
msgid ""
"An implementation of Python written completely in Python. It supports "
"several advanced features not found in other implementations like "
"stackless support and a Just in Time compiler. One of the goals of the "
"project is to encourage experimentation with the language itself by "
"making it easier to modify the interpreter (since it is written in "
"Python).  Additional information is available on `the PyPy project's home"
" page <http://pypy.org/>`_."
msgstr ""

#: ../../reference/introduction.rst:79
msgid ""
"Each of these implementations varies in some way from the language as "
"documented in this manual, or introduces specific information beyond "
"what's covered in the standard Python documentation.  Please refer to the"
" implementation-specific documentation to determine what else you need to"
" know about the specific implementation you're using."
msgstr ""

#: ../../reference/introduction.rst:89
msgid "Notation"
msgstr ""

#: ../../reference/introduction.rst:93
msgid ""
"The descriptions of lexical analysis and syntax use a modified BNF "
"grammar notation.  This uses the following style of definition:"
msgstr ""

#: ../../reference/introduction.rst:100
msgid ""
"The first line says that a ``name`` is an ``lc_letter`` followed by a "
"sequence of zero or more ``lc_letter``\\ s and underscores.  An "
"``lc_letter`` in turn is any of the single characters ``'a'`` through "
"``'z'``.  (This rule is actually adhered to for the names defined in "
"lexical and grammar rules in this document.)"
msgstr ""

#: ../../reference/introduction.rst:105
msgid ""
"Each rule begins with a name (which is the name defined by the rule) and "
"``::=``.  A vertical bar (``|``) is used to separate alternatives; it is "
"the least binding operator in this notation.  A star (``*``) means zero "
"or more repetitions of the preceding item; likewise, a plus (``+``) means"
" one or more repetitions, and a phrase enclosed in square brackets (``[ "
"]``) means zero or one occurrences (in other words, the enclosed phrase "
"is optional).  The ``*`` and ``+`` operators bind as tightly as possible;"
" parentheses are used for grouping.  Literal strings are enclosed in "
"quotes.  White space is only meaningful to separate tokens. Rules are "
"normally contained on a single line; rules with many alternatives may be "
"formatted alternatively with each line after the first beginning with a "
"vertical bar."
msgstr ""

#: ../../reference/introduction.rst:119
msgid ""
"In lexical definitions (as the example above), two more conventions are "
"used: Two literal characters separated by three dots mean a choice of any"
" single character in the given (inclusive) range of ASCII characters.  A "
"phrase between angular brackets (``<...>``) gives an informal description"
" of the symbol defined; e.g., this could be used to describe the notion "
"of 'control character' if needed."
msgstr ""

#: ../../reference/introduction.rst:126
msgid ""
"Even though the notation used is almost the same, there is a big "
"difference between the meaning of lexical and syntactic definitions: a "
"lexical definition operates on the individual characters of the input "
"source, while a syntax definition operates on the stream of tokens "
"generated by the lexical analysis. All uses of BNF in the next chapter "
"(\"Lexical Analysis\") are lexical definitions; uses in subsequent "
"chapters are syntactic definitions."
msgstr ""

#: ../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr ""

#: ../../reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream "
"of *tokens*, generated by the *lexical analyzer*.  This chapter describes"
" how the lexical analyzer breaks a file into tokens."
msgstr ""

#: ../../reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a "
"source file can be given by an encoding declaration and defaults to "
"UTF-8, see :pep:`3120` for details.  If the source file cannot be "
"decoded, a :exc:`SyntaxError` is raised."
msgstr ""

#: ../../reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr ""

#: ../../reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr ""

#: ../../reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr ""

#: ../../reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  "
"Statements cannot cross logical line boundaries except where NEWLINE is "
"allowed by the syntax (e.g., between statements in compound statements). "
"A logical line is constructed from one or more *physical lines* by "
"following the explicit or implicit *line joining* rules."
msgstr ""

#: ../../reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr ""

#: ../../reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line"
" termination sequences can be used - the Unix form using ASCII LF "
"(linefeed), the Windows form using the ASCII sequence CR LF (return "
"followed by linefeed), or the old Macintosh form using the ASCII CR "
"(return) character.  All of these forms can be used equally, regardless "
"of platform. The end of input also serves as an implicit terminator for "
"the final physical line."
msgstr ""

#: ../../reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python "
"APIs using the standard C conventions for newline characters (the ``\\n``"
" character, representing ASCII LF, is the line terminator)."
msgstr ""

#: ../../reference/lexical_analysis.rst:65
msgid "Comments"
msgstr ""

#: ../../reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a "
"string literal, and ends at the end of the physical line.  A comment "
"signifies the end of the logical line unless the implicit line joining "
"rules are invoked. Comments are ignored by the syntax."
msgstr ""

#: ../../reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr ""

#: ../../reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the"
" regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is "
"processed as an encoding declaration; the first group of this expression "
"names the encoding of the source code file. The encoding declaration must"
" appear on a line of its own. If it is the second line, the first line "
"must also be a comment-only line. The recommended forms of an encoding "
"expression are ::"
msgstr ""

#: ../../reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr ""

#: ../../reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr ""

#: ../../reference/lexical_analysis.rst:99
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""

#: ../../reference/lexical_analysis.rst:104
msgid ""
"If an encoding is declared, the encoding name must be recognized by "
"Python. The encoding is used for all lexical analysis, including string "
"literals, comments and identifiers."
msgstr ""

#: ../../reference/lexical_analysis.rst:114
msgid "Explicit line joining"
msgstr ""

#: ../../reference/lexical_analysis.rst:118
msgid ""
"Two or more physical lines may be joined into logical lines using "
"backslash characters (``\\``), as follows: when a physical line ends in a"
" backslash that is not part of a string literal or comment, it is joined "
"with the following forming a single logical line, deleting the backslash "
"and the following end-of-line character.  For example::"
msgstr ""

#: ../../reference/lexical_analysis.rst:129
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does "
"not continue a comment.  A backslash does not continue a token except for"
" string literals (i.e., tokens other than string literals cannot be split"
" across physical lines using a backslash).  A backslash is illegal "
"elsewhere on a line outside a string literal."
msgstr ""

#: ../../reference/lexical_analysis.rst:139
msgid "Implicit line joining"
msgstr ""

#: ../../reference/lexical_analysis.rst:141
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""

#: ../../reference/lexical_analysis.rst:149
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are "
"allowed. There is no NEWLINE token between implicit continuation lines.  "
"Implicitly continued lines can also occur within triple-quoted strings "
"(see below); in that case they cannot carry comments."
msgstr ""

#: ../../reference/lexical_analysis.rst:159
msgid "Blank lines"
msgstr ""

#: ../../reference/lexical_analysis.rst:163
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. "
"one containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""

#: ../../reference/lexical_analysis.rst:174
msgid "Indentation"
msgstr ""

#: ../../reference/lexical_analysis.rst:178
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line "
"is used to compute the indentation level of the line, which in turn is "
"used to determine the grouping of statements."
msgstr ""

#: ../../reference/lexical_analysis.rst:182
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that "
"the total number of characters up to and including the replacement is a "
"multiple of eight (this is intended to be the same rule as used by Unix)."
"  The total number of spaces preceding the first non-blank character then"
" determines the line's indentation.  Indentation cannot be split over "
"multiple physical lines using backslashes; the whitespace up to the first"
" backslash determines the indentation."
msgstr ""

#: ../../reference/lexical_analysis.rst:190
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in"
" spaces; a :exc:`TabError` is raised in that case."
msgstr ""

#: ../../reference/lexical_analysis.rst:194
msgid ""
"**Cross-platform compatibility note:** because of the nature of text "
"editors on non-UNIX platforms, it is unwise to use a mixture of spaces "
"and tabs for the indentation in a single source file.  It should also be "
"noted that different platforms may explicitly limit the maximum "
"indentation level."
msgstr ""

#: ../../reference/lexical_analysis.rst:199
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect "
"(for instance, they may reset the space count to zero)."
msgstr ""

#: ../../reference/lexical_analysis.rst:206
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT "
"and DEDENT tokens, using a stack, as follows."
msgstr ""

#: ../../reference/lexical_analysis.rst:209
msgid ""
"Before the first line of the file is read, a single zero is pushed on the"
" stack; this will never be popped off again.  The numbers pushed on the "
"stack will always be strictly increasing from bottom to top.  At the "
"beginning of each logical line, the line's indentation level is compared "
"to the top of the stack. If it is equal, nothing happens. If it is "
"larger, it is pushed on the stack, and one INDENT token is generated.  If"
" it is smaller, it *must* be one of the numbers occurring on the stack; "
"all numbers on the stack that are larger are popped off, and for each "
"number popped off a DEDENT token is generated.  At the end of the file, a"
" DEDENT token is generated for each number remaining on the stack that is"
" larger than zero."
msgstr ""

#: ../../reference/lexical_analysis.rst:220
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""

#: ../../reference/lexical_analysis.rst:235
msgid "The following example shows various indentation errors::"
msgstr ""

#: ../../reference/lexical_analysis.rst:245
msgid ""
"(Actually, the first three errors are detected by the parser; only the "
"last error is found by the lexical analyzer --- the indentation of "
"``return r`` does not match a level popped off the stack.)"
msgstr ""

#: ../../reference/lexical_analysis.rst:253
msgid "Whitespace between tokens"
msgstr ""

#: ../../reference/lexical_analysis.rst:255
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably"
" to separate tokens.  Whitespace is needed between two tokens only if "
"their concatenation could otherwise be interpreted as a different token "
"(e.g., ab is one token, but a b is two tokens)."
msgstr ""

#: ../../reference/lexical_analysis.rst:265
msgid "Other tokens"
msgstr ""

#: ../../reference/lexical_analysis.rst:267
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and "
"*delimiters*. Whitespace characters (other than line terminators, "
"discussed earlier) are not tokens, but serve to delimit tokens. Where "
"ambiguity exists, a token comprises the longest possible string that "
"forms a legal token, when read from left to right."
msgstr ""

#: ../../reference/lexical_analysis.rst:277
msgid "Identifiers and keywords"
msgstr ""

#: ../../reference/lexical_analysis.rst:281
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""

#: ../../reference/lexical_analysis.rst:284
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard "
"annex UAX-31, with elaboration and changes as defined below; see also "
":pep:`3131` for further details."
msgstr ""

#: ../../reference/lexical_analysis.rst:288
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the "
"first character, the digits ``0`` through ``9``."
msgstr ""

#: ../../reference/lexical_analysis.rst:293
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the "
":mod:`unicodedata` module."
msgstr ""

#: ../../reference/lexical_analysis.rst:297
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""

#: ../../reference/lexical_analysis.rst:306
msgid "The Unicode category codes mentioned above stand for:"
msgstr ""

#: ../../reference/lexical_analysis.rst:308
msgid "*Lu* - uppercase letters"
msgstr ""

#: ../../reference/lexical_analysis.rst:309
msgid "*Ll* - lowercase letters"
msgstr ""

#: ../../reference/lexical_analysis.rst:310
msgid "*Lt* - titlecase letters"
msgstr ""

#: ../../reference/lexical_analysis.rst:311
msgid "*Lm* - modifier letters"
msgstr ""

#: ../../reference/lexical_analysis.rst:312
msgid "*Lo* - other letters"
msgstr ""

#: ../../reference/lexical_analysis.rst:313
msgid "*Nl* - letter numbers"
msgstr ""

#: ../../reference/lexical_analysis.rst:314
msgid "*Mn* - nonspacing marks"
msgstr ""

#: ../../reference/lexical_analysis.rst:315
msgid "*Mc* - spacing combining marks"
msgstr ""

#: ../../reference/lexical_analysis.rst:316
msgid "*Nd* - decimal numbers"
msgstr ""

#: ../../reference/lexical_analysis.rst:317
msgid "*Pc* - connector punctuations"
msgstr ""

#: ../../reference/lexical_analysis.rst:318
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt "
"<http://www.unicode.org/Public/12.1.0/ucd/PropList.txt>`_ to support "
"backwards compatibility"
msgstr ""

#: ../../reference/lexical_analysis.rst:321
msgid "*Other_ID_Continue* - likewise"
msgstr ""

#: ../../reference/lexical_analysis.rst:323
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""

#: ../../reference/lexical_analysis.rst:326
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at "
"https://www.unicode.org/Public/13.0.0/ucd/DerivedCoreProperties.txt"
msgstr ""

#: ../../reference/lexical_analysis.rst:334
msgid "Keywords"
msgstr ""

#: ../../reference/lexical_analysis.rst:340
msgid ""
"The following identifiers are used as reserved words, or *keywords* of "
"the language, and cannot be used as ordinary identifiers.  They must be "
"spelled exactly as written here:"
msgstr ""

#: ../../reference/lexical_analysis.rst:360
msgid "Reserved classes of identifiers"
msgstr ""

#: ../../reference/lexical_analysis.rst:362
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings."
"  These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""

#: ../../reference/lexical_analysis.rst:376
msgid "``_*``"
msgstr ""

#: ../../reference/lexical_analysis.rst:367
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` "
"is used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`builtins` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""

#: ../../reference/lexical_analysis.rst:374
msgid ""
"The name ``_`` is often used in conjunction with internationalization; "
"refer to the documentation for the :mod:`gettext` module for more "
"information on this convention."
msgstr ""

#: ../../reference/lexical_analysis.rst:384
msgid "``__*__``"
msgstr ""

#: ../../reference/lexical_analysis.rst:379
msgid ""
"System-defined names, informally known as \"dunder\" names. These names "
"are defined by the interpreter and its implementation (including the "
"standard library). Current system names are discussed in the "
":ref:`specialnames` section and elsewhere. More will likely be defined in"
" future versions of Python.  *Any* use of ``__*__`` names, in any "
"context, that does not follow explicitly documented use, is subject to "
"breakage without warning."
msgstr ""

#: ../../reference/lexical_analysis.rst:391
msgid "``__*``"
msgstr ""

#: ../../reference/lexical_analysis.rst:387
msgid ""
"Class-private names.  Names in this category, when used within the "
"context of a class definition, are re-written to use a mangled form to "
"help avoid name clashes between \"private\" attributes of base and "
"derived classes. See section :ref:`atom-identifiers`."
msgstr ""

#: ../../reference/lexical_analysis.rst:400
msgid "Literals are notations for constant values of some built-in types."
msgstr ""

#: ../../reference/lexical_analysis.rst:411
msgid "String and Bytes literals"
msgstr ""

#: ../../reference/lexical_analysis.rst:413
msgid "String literals are described by the following lexical definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:438
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` or "
":token:`bytesprefix` and the rest of the literal. The source character "
"set is defined by the encoding declaration; it is UTF-8 if no encoding "
"declaration is given in the source file; see section :ref:`encodings`."
msgstr ""

#: ../../reference/lexical_analysis.rst:448
msgid ""
"In plain English: Both types of literals can be enclosed in matching "
"single quotes (``'``) or double quotes (``\"``).  They can also be "
"enclosed in matching groups of three single or double quotes (these are "
"generally referred to as *triple-quoted strings*).  The backslash "
"(``\\``) character is used to escape characters that otherwise have a "
"special meaning, such as newline, backslash itself, or the quote "
"character."
msgstr ""

#: ../../reference/lexical_analysis.rst:459
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce "
"an instance of the :class:`bytes` type instead of the :class:`str` type."
"  They may only contain ASCII characters; bytes with a numeric value of "
"128 or greater must be expressed with escapes."
msgstr ""

#: ../../reference/lexical_analysis.rst:468
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially."
" Given that Python 2.x's raw unicode literals behave differently than "
"Python 3.x's the ``'ur'`` syntax is not supported."
msgstr ""

#: ../../reference/lexical_analysis.rst:475
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""

#: ../../reference/lexical_analysis.rst:479
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to"
" simplify the maintenance of dual Python 2.x and 3.x codebases. See "
":pep:`414` for more information."
msgstr ""

#: ../../reference/lexical_analysis.rst:488
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a "
":dfn:`formatted string literal`; see :ref:`f-strings`.  The ``'f'`` may "
"be combined with ``'r'``, but not with ``'b'`` or ``'u'``, therefore raw "
"formatted strings are possible, but formatted bytes literals are not."
msgstr ""

#: ../../reference/lexical_analysis.rst:493
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and"
" are retained), except that three unescaped quotes in a row terminate the"
" literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""

#: ../../reference/lexical_analysis.rst:512
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in "
"string and bytes literals are interpreted according to rules similar to "
"those used by Standard C.  The recognized escape sequences are:"
msgstr ""

#: ../../reference/lexical_analysis.rst:517
#: ../../reference/lexical_analysis.rst:550
msgid "Escape Sequence"
msgstr ""

#: ../../reference/lexical_analysis.rst:517
#: ../../reference/lexical_analysis.rst:550
msgid "Notes"
msgstr ""

#: ../../reference/lexical_analysis.rst:519
msgid "``\\newline``"
msgstr ""

#: ../../reference/lexical_analysis.rst:519
msgid "Backslash and newline ignored"
msgstr ""

#: ../../reference/lexical_analysis.rst:521
msgid "``\\\\``"
msgstr ""

#: ../../reference/lexical_analysis.rst:521
msgid "Backslash (``\\``)"
msgstr ""

#: ../../reference/lexical_analysis.rst:523
msgid "``\\'``"
msgstr ""

#: ../../reference/lexical_analysis.rst:523
msgid "Single quote (``'``)"
msgstr ""

#: ../../reference/lexical_analysis.rst:525
msgid "``\\\"``"
msgstr ""

#: ../../reference/lexical_analysis.rst:525
msgid "Double quote (``\"``)"
msgstr ""

#: ../../reference/lexical_analysis.rst:527
msgid "``\\a``"
msgstr ""

#: ../../reference/lexical_analysis.rst:527
msgid "ASCII Bell (BEL)"
msgstr ""

#: ../../reference/lexical_analysis.rst:529
msgid "``\\b``"
msgstr ""

#: ../../reference/lexical_analysis.rst:529
msgid "ASCII Backspace (BS)"
msgstr ""

#: ../../reference/lexical_analysis.rst:531
msgid "``\\f``"
msgstr ""

#: ../../reference/lexical_analysis.rst:531
msgid "ASCII Formfeed (FF)"
msgstr ""

#: ../../reference/lexical_analysis.rst:533
msgid "``\\n``"
msgstr ""

#: ../../reference/lexical_analysis.rst:533
msgid "ASCII Linefeed (LF)"
msgstr ""

#: ../../reference/lexical_analysis.rst:535
msgid "``\\r``"
msgstr ""

#: ../../reference/lexical_analysis.rst:535
msgid "ASCII Carriage Return (CR)"
msgstr ""

#: ../../reference/lexical_analysis.rst:537
msgid "``\\t``"
msgstr ""

#: ../../reference/lexical_analysis.rst:537
msgid "ASCII Horizontal Tab (TAB)"
msgstr ""

#: ../../reference/lexical_analysis.rst:539
msgid "``\\v``"
msgstr ""

#: ../../reference/lexical_analysis.rst:539
msgid "ASCII Vertical Tab (VT)"
msgstr ""

#: ../../reference/lexical_analysis.rst:541
msgid "``\\ooo``"
msgstr ""

#: ../../reference/lexical_analysis.rst:541
msgid "Character with octal value *ooo*"
msgstr ""

#: ../../reference/lexical_analysis.rst:541
msgid "(1,3)"
msgstr ""

#: ../../reference/lexical_analysis.rst:544
msgid "``\\xhh``"
msgstr ""

#: ../../reference/lexical_analysis.rst:544
msgid "Character with hex value *hh*"
msgstr ""

#: ../../reference/lexical_analysis.rst:544
msgid "(2,3)"
msgstr ""

#: ../../reference/lexical_analysis.rst:547
msgid "Escape sequences only recognized in string literals are:"
msgstr ""

#: ../../reference/lexical_analysis.rst:552
msgid "``\\N{name}``"
msgstr ""

#: ../../reference/lexical_analysis.rst:552
msgid "Character named *name* in the Unicode database"
msgstr ""

#: ../../reference/lexical_analysis.rst:552
msgid "\\(4)"
msgstr ""

#: ../../reference/lexical_analysis.rst:555
msgid "``\\uxxxx``"
msgstr ""

#: ../../reference/lexical_analysis.rst:555
msgid "Character with 16-bit hex value *xxxx*"
msgstr ""

#: ../../reference/lexical_analysis.rst:555
msgid "\\(5)"
msgstr ""

#: ../../reference/lexical_analysis.rst:558
msgid "``\\Uxxxxxxxx``"
msgstr ""

#: ../../reference/lexical_analysis.rst:558
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr ""

#: ../../reference/lexical_analysis.rst:558
msgid "\\(6)"
msgstr ""

#: ../../reference/lexical_analysis.rst:562
msgid "Notes:"
msgstr ""

#: ../../reference/lexical_analysis.rst:565
msgid "As in Standard C, up to three octal digits are accepted."
msgstr ""

#: ../../reference/lexical_analysis.rst:568
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""

#: ../../reference/lexical_analysis.rst:571
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with "
"the given value. In a string literal, these escapes denote a Unicode "
"character with the given value."
msgstr ""

#: ../../reference/lexical_analysis.rst:576
msgid "Support for name aliases [#]_ has been added."
msgstr ""

#: ../../reference/lexical_analysis.rst:580
msgid "Exactly four hex digits are required."
msgstr ""

#: ../../reference/lexical_analysis.rst:583
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits "
"are required."
msgstr ""

#: ../../reference/lexical_analysis.rst:589
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the "
"string unchanged, i.e., *the backslash is left in the result*.  (This "
"behavior is useful when debugging: if an escape sequence is mistyped, the"
" resulting output is more easily recognized as broken.)  It is also "
"important to note that the escape sequences only recognized in string "
"literals fall into the category of unrecognized escapes for bytes "
"literals."
msgstr ""

#: ../../reference/lexical_analysis.rst:596
msgid ""
"Unrecognized escape sequences produce a :exc:`DeprecationWarning`.  In a "
"future Python version they will be a :exc:`SyntaxWarning` and eventually "
"a :exc:`SyntaxError`."
msgstr ""

#: ../../reference/lexical_analysis.rst:601
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double "
"quote; ``r\"\\\"`` is not a valid string literal (even a raw string "
"cannot end in an odd number of backslashes).  Specifically, *a raw "
"literal cannot end in a single backslash* (since the backslash would "
"escape the following quote character).  Note also that a single backslash"
" followed by a newline is interpreted as those two characters as part of "
"the literal, *not* as a line continuation."
msgstr ""

#: ../../reference/lexical_analysis.rst:614
msgid "String literal concatenation"
msgstr ""

#: ../../reference/lexical_analysis.rst:616
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their "
"meaning is the same as their concatenation.  Thus, ``\"hello\" 'world'`` "
"is equivalent to ``\"helloworld\"``.  This feature can be used to reduce "
"the number of backslashes needed, to split long strings conveniently "
"across long lines, or even to add comments to parts of strings, for "
"example::"
msgstr ""

#: ../../reference/lexical_analysis.rst:627
msgid ""
"Note that this feature is defined at the syntactical level, but "
"implemented at compile time.  The '+' operator must be used to "
"concatenate string expressions at run time.  Also note that literal "
"concatenation can use different quoting styles for each component (even "
"mixing raw strings and triple quoted strings), and formatted string "
"literals may be concatenated with plain string literals."
msgstr ""

#: ../../reference/lexical_analysis.rst:648
msgid "Formatted string literals"
msgstr ""

#: ../../reference/lexical_analysis.rst:652
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces "
"``{}``. While other string literals always have a constant value, "
"formatted strings are really expressions evaluated at run time."
msgstr ""

#: ../../reference/lexical_analysis.rst:658
msgid ""
"Escape sequences are decoded like in ordinary string literals (except "
"when a literal is also marked as a raw string).  After decoding, the "
"grammar for the contents of the string is:"
msgstr ""

#: ../../reference/lexical_analysis.rst:672
msgid ""
"The parts of the string outside curly braces are treated literally, "
"except that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced "
"with the corresponding single curly brace.  A single opening curly "
"bracket ``'{'`` marks a replacement field, which starts with a Python "
"expression. To display both the expression text and its value after "
"evaluation, (useful in debugging), an equal sign ``'='`` may be added "
"after the expression. A conversion field, introduced by an exclamation "
"point ``'!'`` may follow.  A format specifier may also be appended, "
"introduced by a colon ``':'``. A replacement field ends with a closing "
"curly bracket ``'}'``."
msgstr ""

#: ../../reference/lexical_analysis.rst:682
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. "
"Replacement expressions can contain line breaks (e.g. in triple-quoted "
"strings), but they cannot contain comments.  Each expression is evaluated"
" in the context where the formatted string literal appears, in order from"
" left to right."
msgstr ""

#: ../../reference/lexical_analysis.rst:691
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions"
" in formatted string literals due to a problem with the implementation."
msgstr ""

#: ../../reference/lexical_analysis.rst:696
msgid ""
"When the equal sign ``'='`` is provided, the output will have the "
"expression text, the ``'='`` and the evaluated value. Spaces after the "
"opening brace ``'{'``, within the expression and after the ``'='`` are "
"all retained in the output. By default, the ``'='`` causes the "
":func:`repr` of the expression to be provided, unless there is a format "
"specified. When a format is specified it defaults to the :func:`str` of "
"the expression unless a conversion ``'!r'`` is declared."
msgstr ""

#: ../../reference/lexical_analysis.rst:704
msgid "The equal sign ``'='``."
msgstr ""

#: ../../reference/lexical_analysis.rst:707
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on "
"the result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls "
":func:`ascii`."
msgstr ""

#: ../../reference/lexical_analysis.rst:711
msgid ""
"The result is then formatted using the :func:`format` protocol.  The "
"format specifier is passed to the :meth:`__format__` method of the "
"expression or conversion result.  An empty string is passed when the "
"format specifier is omitted.  The formatted result is then included in "
"the final value of the whole string."
msgstr ""

#: ../../reference/lexical_analysis.rst:717
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply-nested "
"replacement fields. The :ref:`format specifier mini-language "
"<formatspec>` is the same as that used by the string .format() method."
msgstr ""

#: ../../reference/lexical_analysis.rst:723
msgid ""
"Formatted string literals may be concatenated, but replacement fields "
"cannot be split across literals."
msgstr ""

#: ../../reference/lexical_analysis.rst:726
msgid "Some examples of formatted string literals::"
msgstr ""

#: ../../reference/lexical_analysis.rst:758
msgid ""
"A consequence of sharing the same syntax as regular string literals is "
"that characters in the replacement fields must not conflict with the "
"quoting used in the outer formatted string literal::"
msgstr ""

#: ../../reference/lexical_analysis.rst:765
msgid ""
"Backslashes are not allowed in format expressions and will raise an "
"error::"
msgstr ""

#: ../../reference/lexical_analysis.rst:770
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr ""

#: ../../reference/lexical_analysis.rst:777
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do "
"not include expressions."
msgstr ""

#: ../../reference/lexical_analysis.rst:788
msgid ""
"See also :pep:`498` for the proposal that added formatted string "
"literals, and :meth:`str.format`, which uses a related format string "
"mechanism."
msgstr ""

#: ../../reference/lexical_analysis.rst:795
msgid "Numeric literals"
msgstr ""

#: ../../reference/lexical_analysis.rst:801
msgid ""
"There are three types of numeric literals: integers, floating point "
"numbers, and imaginary numbers.  There are no complex literals (complex "
"numbers can be formed by adding a real number and an imaginary number)."
msgstr ""

#: ../../reference/lexical_analysis.rst:805
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is"
" actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""

#: ../../reference/lexical_analysis.rst:819
msgid "Integer literals"
msgstr ""

#: ../../reference/lexical_analysis.rst:821
msgid "Integer literals are described by the following lexical definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:835
msgid ""
"There is no limit for the length of integer literals apart from what can "
"be stored in available memory."
msgstr ""

#: ../../reference/lexical_analysis.rst:838
msgid ""
"Underscores are ignored for determining the numeric value of the literal."
"  They can be used to group digits for enhanced readability.  One "
"underscore can occur between digits, and after base specifiers like "
"``0x``."
msgstr ""

#: ../../reference/lexical_analysis.rst:842
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. "
"This is for disambiguation with C-style octal literals, which Python used"
" before version 3.0."
msgstr ""

#: ../../reference/lexical_analysis.rst:846
msgid "Some examples of integer literals::"
msgstr ""

#: ../../reference/lexical_analysis.rst:852
#: ../../reference/lexical_analysis.rst:884
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr ""

#: ../../reference/lexical_analysis.rst:863
msgid "Floating point literals"
msgstr ""

#: ../../reference/lexical_analysis.rst:865
msgid ""
"Floating point literals are described by the following lexical "
"definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:875
msgid ""
"Note that the integer and exponent parts are always interpreted using "
"radix 10. For example, ``077e010`` is legal, and denotes the same number "
"as ``77e10``. The allowed range of floating point literals is "
"implementation-dependent.  As in integer literals, underscores are "
"supported for digit grouping."
msgstr ""

#: ../../reference/lexical_analysis.rst:880
msgid "Some examples of floating point literals::"
msgstr ""

#: ../../reference/lexical_analysis.rst:893
msgid "Imaginary literals"
msgstr ""

#: ../../reference/lexical_analysis.rst:895
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:900
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and "
"have the same restrictions on their range.  To create a complex number "
"with a nonzero real part, add a floating point number to it, e.g., "
"``(3+4j)``.  Some examples of imaginary literals::"
msgstr ""

#: ../../reference/lexical_analysis.rst:912
msgid "Operators"
msgstr ""

#: ../../reference/lexical_analysis.rst:916
msgid "The following tokens are operators:"
msgstr ""

#: ../../reference/lexical_analysis.rst:929
msgid "Delimiters"
msgstr ""

#: ../../reference/lexical_analysis.rst:933
msgid "The following tokens serve as delimiters in the grammar:"
msgstr ""

#: ../../reference/lexical_analysis.rst:942
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. "
"The second half of the list, the augmented assignment operators, serve "
"lexically as delimiters, but also perform an operation."
msgstr ""

#: ../../reference/lexical_analysis.rst:947
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""

#: ../../reference/lexical_analysis.rst:954
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional "
"error:"
msgstr ""

#: ../../reference/lexical_analysis.rst:964
msgid "http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr ""

#: ../../reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr ""

#: ../../reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several "
"simple statements may occur on a single line separated by semicolons.  "
"The syntax for simple statements is:"
msgstr ""

#: ../../reference/simple_stmts.rst:36
msgid "Expression statements"
msgstr ""

#: ../../reference/simple_stmts.rst:43
msgid ""
"Expression statements are used (mostly interactively) to compute and "
"write a value, or (usually) to call a procedure (a function that returns "
"no meaningful result; in Python, procedures return the value ``None``).  "
"Other uses of expression statements are allowed and occasionally useful."
"  The syntax for an expression statement is:"
msgstr ""

#: ../../reference/simple_stmts.rst:52
msgid ""
"An expression statement evaluates the expression list (which may be a "
"single expression)."
msgstr ""

#: ../../reference/simple_stmts.rst:64
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string "
"is written to standard output on a line by itself (except if the result "
"is ``None``, so that procedure calls do not cause any output.)"
msgstr ""

#: ../../reference/simple_stmts.rst:72
msgid "Assignment statements"
msgstr ""

#: ../../reference/simple_stmts.rst:82
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""

#: ../../reference/simple_stmts.rst:96
msgid ""
"(See section :ref:`primaries` for the syntax definitions for "
"*attributeref*, *subscription*, and *slicing*.)"
msgstr ""

#: ../../reference/simple_stmts.rst:99
msgid ""
"An assignment statement evaluates the expression list (remember that this"
" can be a single expression or a comma-separated list, the latter "
"yielding a tuple) and assigns the single resulting object to each of the "
"target lists, from left to right."
msgstr ""

#: ../../reference/simple_stmts.rst:108
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute "
"reference, subscription or slicing), the mutable object must ultimately "
"perform the assignment and decide about its validity, and may raise an "
"exception if the assignment is unacceptable.  The rules observed by "
"various types and the exceptions raised are given with the definition of "
"the object types (see section :ref:`types`)."
msgstr ""

#: ../../reference/simple_stmts.rst:121
msgid ""
"Assignment of an object to a target list, optionally enclosed in "
"parentheses or square brackets, is recursively defined as follows."
msgstr ""

#: ../../reference/simple_stmts.rst:124
msgid ""
"If the target list is a single target with no trailing comma, optionally "
"in parentheses, the object is assigned to that target."
msgstr ""

#: ../../reference/simple_stmts.rst:127 ../../reference/simple_stmts.rst:139
msgid ""
"Else: The object must be an iterable with the same number of items as "
"there are targets in the target list, and the items are assigned, from "
"left to right, to the corresponding targets."
msgstr ""

#: ../../reference/simple_stmts.rst:131
msgid ""
"If the target list contains one target prefixed with an asterisk, called "
"a \"starred\" target: The object must be an iterable with at least as "
"many items as there are targets in the target list, minus one.  The first"
" items of the iterable are assigned, from left to right, to the targets "
"before the starred target.  The final items of the iterable are assigned "
"to the targets after the starred target.  A list of the remaining items "
"in the iterable is then assigned to the starred target (the list can be "
"empty)."
msgstr ""

#: ../../reference/simple_stmts.rst:143
msgid ""
"Assignment of an object to a single target is recursively defined as "
"follows."
msgstr ""

#: ../../reference/simple_stmts.rst:145
msgid "If the target is an identifier (name):"
msgstr ""

#: ../../reference/simple_stmts.rst:147
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in "
"the current local namespace."
msgstr ""

#: ../../reference/simple_stmts.rst:151
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the"
" outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""

#: ../../reference/simple_stmts.rst:156
msgid ""
"The name is rebound if it was already bound.  This may cause the "
"reference count for the object previously bound to the name to reach "
"zero, causing the object to be deallocated and its destructor (if it has "
"one) to be called."
msgstr ""

#: ../../reference/simple_stmts.rst:162
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given "
"attribute; if it cannot perform the assignment, it raises an exception "
"(usually but not necessarily :exc:`AttributeError`)."
msgstr ""

#: ../../reference/simple_stmts.rst:171
msgid ""
"Note: If the object is a class instance and the attribute reference "
"occurs on both sides of the assignment operator, the right-hand side "
"expression, ``a.x`` can access either an instance attribute or (if no "
"instance attribute exists) a class attribute.  The left-hand side target "
"``a.x`` is always set as an instance attribute, creating it if necessary."
"  Thus, the two occurrences of ``a.x`` do not necessarily refer to the "
"same attribute: if the right-hand side expression refers to a class "
"attribute, the left-hand side creates a new instance attribute as the "
"target of the assignment::"
msgstr ""

#: ../../reference/simple_stmts.rst:185
msgid ""
"This description does not necessarily apply to descriptor attributes, "
"such as properties created with :func:`property`."
msgstr ""

#: ../../reference/simple_stmts.rst:192
msgid ""
"If the target is a subscription: The primary expression in the reference "
"is evaluated.  It should yield either a mutable sequence object (such as "
"a list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""

#: ../../reference/simple_stmts.rst:201
msgid ""
"If the primary is a mutable sequence object (such as a list), the "
"subscript must yield an integer.  If it is negative, the sequence's "
"length is added to it.  The resulting value must be a nonnegative integer"
" less than the sequence's length, and the sequence is asked to assign the"
" assigned object to its item with that index.  If the index is out of "
"range, :exc:`IndexError` is raised (assignment to a subscripted sequence "
"cannot add new items to a list)."
msgstr ""

#: ../../reference/simple_stmts.rst:212
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping "
"is then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with"
" the same key value, or insert a new key/value pair (if no key with the "
"same value existed)."
msgstr ""

#: ../../reference/simple_stmts.rst:218
msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr ""

#: ../../reference/simple_stmts.rst:223
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  "
"The assigned object should be a sequence object of the same type.  Next, "
"the lower and upper bound expressions are evaluated, insofar they are "
"present; defaults are zero and the sequence's length.  The bounds should "
"evaluate to integers. If either bound is negative, the sequence's length "
"is added to it.  The resulting bounds are clipped to lie between zero and"
" the sequence's length, inclusive.  Finally, the sequence object is asked"
" to replace the slice with the items of the assigned sequence.  The "
"length of the slice may be different from the length of the assigned "
"sequence, thus changing the length of the target sequence, if the target "
"sequence allows it."
msgstr ""

#: ../../reference/simple_stmts.rst:237
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""

#: ../../reference/simple_stmts.rst:241
msgid ""
"Although the definition of assignment implies that overlaps between the "
"left-hand side and the right-hand side are 'simultaneous' (for example "
"``a, b = b, a`` swaps two variables), overlaps *within* the collection of"
" assigned-to variables occur left-to-right, sometimes resulting in "
"confusion.  For instance, the following program prints ``[0, 2]``::"
msgstr ""

#: ../../reference/simple_stmts.rst:255
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ""

#: ../../reference/simple_stmts.rst:256
msgid "The specification for the ``*target`` feature."
msgstr ""

#: ../../reference/simple_stmts.rst:262
msgid "Augmented assignment statements"
msgstr ""

#: ../../reference/simple_stmts.rst:280
msgid ""
"Augmented assignment is the combination, in a single statement, of a "
"binary operation and an assignment statement:"
msgstr ""

#: ../../reference/simple_stmts.rst:289
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last "
"three symbols.)"
msgstr ""

#: ../../reference/simple_stmts.rst:292
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the "
"two operands, and assigns the result to the original target.  The target "
"is only evaluated once."
msgstr ""

#: ../../reference/simple_stmts.rst:297
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as "
"``x = x + 1`` to achieve a similar, but not exactly equal effect. In the "
"augmented version, ``x`` is only evaluated once. Also, when possible, the"
" actual operation is performed *in-place*, meaning that rather than "
"creating a new object and assigning that to the target, the old object is"
" modified instead."
msgstr ""

#: ../../reference/simple_stmts.rst:303
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand "
"side *before* evaluating the right-hand side.  For example, ``a[i] += "
"f(x)`` first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs "
"the addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""

#: ../../reference/simple_stmts.rst:308
msgid ""
"With the exception of assigning to tuples and multiple targets in a "
"single statement, the assignment done by augmented assignment statements "
"is handled the same way as normal assignments. Similarly, with the "
"exception of the possible *in-place* behavior, the binary operation "
"performed by augmented assignment is the same as the normal binary "
"operations."
msgstr ""

#: ../../reference/simple_stmts.rst:314
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""

#: ../../reference/simple_stmts.rst:321
msgid "Annotated assignment statements"
msgstr ""

#: ../../reference/simple_stmts.rst:328
msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, "
"in a single statement, of a variable or attribute annotation and an "
"optional assignment statement:"
msgstr ""

#: ../../reference/simple_stmts.rst:335
msgid ""
"The difference from normal :ref:`assignment` is that only single target "
"is allowed."
msgstr ""

#: ../../reference/simple_stmts.rst:337
msgid ""
"For simple names as assignment targets, if in class or module scope, the "
"annotations are evaluated and stored in a special class or module "
"attribute :attr:`__annotations__` that is a dictionary mapping from "
"variable names (mangled if private) to evaluated annotations. This "
"attribute is writable and is automatically created at the start of class "
"or module body execution, if annotations are found statically."
msgstr ""

#: ../../reference/simple_stmts.rst:345
msgid ""
"For expressions as assignment targets, the annotations are evaluated if "
"in class or module scope, but not stored."
msgstr ""

#: ../../reference/simple_stmts.rst:348
msgid ""
"If a name is annotated in a function scope, then this name is local for "
"that scope. Annotations are never evaluated and stored in function "
"scopes."
msgstr ""

#: ../../reference/simple_stmts.rst:351
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If "
"the right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last :meth:`__setitem__` "
"or :meth:`__setattr__` call."
msgstr ""

#: ../../reference/simple_stmts.rst:360
msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing"
" them through comments."
msgstr ""

#: ../../reference/simple_stmts.rst:366
msgid ":pep:`484` - Type hints"
msgstr ""

#: ../../reference/simple_stmts.rst:365
msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and"
" IDEs."
msgstr ""

#: ../../reference/simple_stmts.rst:369
msgid ""
"Now annotated assignments allow same expressions in the right hand side "
"as the regular assignments. Previously, some expressions (like un-"
"parenthesized tuple expressions) caused a syntax error."
msgstr ""

#: ../../reference/simple_stmts.rst:378
msgid "The :keyword:`!assert` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:385
msgid ""
"Assert statements are a convenient way to insert debugging assertions "
"into a program:"
msgstr ""

#: ../../reference/simple_stmts.rst:391
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr ""

#: ../../reference/simple_stmts.rst:396
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to "
"::"
msgstr ""

#: ../../reference/simple_stmts.rst:405
msgid ""
"These equivalences assume that :const:`__debug__` and "
":exc:`AssertionError` refer to the built-in variables with those names.  "
"In the current implementation, the built-in variable :const:`__debug__` "
"is ``True`` under normal circumstances, ``False`` when optimization is "
"requested (command line option :option:`-O`).  The current code generator"
" emits no code for an assert statement when optimization is requested at "
"compile time.  Note that it is unnecessary to include the source code for"
" the expression that failed in the error message; it will be displayed as"
" part of the stack trace."
msgstr ""

#: ../../reference/simple_stmts.rst:414
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-"
"in variable is determined when the interpreter starts."
msgstr ""

#: ../../reference/simple_stmts.rst:421
msgid "The :keyword:`!pass` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:431
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""

#: ../../reference/simple_stmts.rst:443
msgid "The :keyword:`!del` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:453
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some "
"hints."
msgstr ""

#: ../../reference/simple_stmts.rst:456
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""

#: ../../reference/simple_stmts.rst:462
msgid ""
"Deletion of a name removes the binding of that name from the local or "
"global namespace, depending on whether the name occurs in a "
":keyword:`global` statement in the same code block.  If the name is "
"unbound, a :exc:`NameError` exception will be raised."
msgstr ""

#: ../../reference/simple_stmts.rst:469
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to"
" the primary object involved; deletion of a slicing is in general "
"equivalent to assignment of an empty slice of the right type (but even "
"this is determined by the sliced object)."
msgstr ""

#: ../../reference/simple_stmts.rst:474
msgid ""
"Previously it was illegal to delete a name from the local namespace if it"
" occurs as a free variable in a nested block."
msgstr ""

#: ../../reference/simple_stmts.rst:482
msgid "The :keyword:`!return` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:492
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""

#: ../../reference/simple_stmts.rst:495
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""

#: ../../reference/simple_stmts.rst:497
msgid ""
":keyword:`return` leaves the current function call with the expression "
"list (or ``None``) as return value."
msgstr ""

#: ../../reference/simple_stmts.rst:502
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really leaving the function."
msgstr ""

#: ../../reference/simple_stmts.rst:506
msgid ""
"In a generator function, the :keyword:`return` statement indicates that "
"the generator is done and will cause :exc:`StopIteration` to be raised. "
"The returned value (if any) is used as an argument to construct "
":exc:`StopIteration` and becomes the :attr:`StopIteration.value` "
"attribute."
msgstr ""

#: ../../reference/simple_stmts.rst:511
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` "
"statement indicates that the asynchronous generator is done and will "
"cause :exc:`StopAsyncIteration` to be raised.  A non-empty "
":keyword:`!return` statement is a syntax error in an asynchronous "
"generator function."
msgstr ""

#: ../../reference/simple_stmts.rst:519
msgid "The :keyword:`!yield` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:531
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The yield statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""

#: ../../reference/simple_stmts.rst:539
msgid "are equivalent to the yield expression statements ::"
msgstr ""

#: ../../reference/simple_stmts.rst:544
msgid ""
"Yield expressions and statements are only used when defining a "
":term:`generator` function, and are only used in the body of the "
"generator function.  Using yield in a function definition is sufficient "
"to cause that definition to create a generator function instead of a "
"normal function."
msgstr ""

#: ../../reference/simple_stmts.rst:549
msgid ""
"For full details of :keyword:`yield` semantics, refer to the "
":ref:`yieldexpr` section."
msgstr ""

#: ../../reference/simple_stmts.rst:555
msgid "The :keyword:`!raise` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:566
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the last "
"exception that was active in the current scope.  If no exception is "
"active in the current scope, a :exc:`RuntimeError` exception is raised "
"indicating that this is an error."
msgstr ""

#: ../../reference/simple_stmts.rst:571
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the "
"exception object.  It must be either a subclass or an instance of "
":class:`BaseException`. If it is a class, the exception instance will be "
"obtained when needed by instantiating the class with no arguments."
msgstr ""

#: ../../reference/simple_stmts.rst:576
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the "
":dfn:`value` is the instance itself."
msgstr ""

#: ../../reference/simple_stmts.rst:581
msgid ""
"A traceback object is normally created automatically when an exception is"
" raised and attached to it as the :attr:`__traceback__` attribute, which "
"is writable. You can create an exception and set your own traceback in "
"one step using the :meth:`with_traceback` exception method (which returns"
" the same exception instance, with its traceback set to its argument), "
"like so::"
msgstr ""

#: ../../reference/simple_stmts.rst:593
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance. If the second "
"expression is an exception instance, it will be attached to the raised "
"exception as the :attr:`__cause__` attribute (which is writable). If the "
"expression is an exception class, the class will be instantiated and the "
"resulting exception instance will be attached to the raised exception as "
"the :attr:`__cause__` attribute. If the raised exception is not handled, "
"both exceptions will be printed::"
msgstr ""

#: ../../reference/simple_stmts.rst:617
msgid ""
"A similar mechanism works implicitly if an exception is raised inside an "
"exception handler or a :keyword:`finally` clause: the previous exception "
"is then attached as the new exception's :attr:`__context__` attribute::"
msgstr ""

#: ../../reference/simple_stmts.rst:636
msgid ""
"Exception chaining can be explicitly suppressed by specifying "
":const:`None` in the ``from`` clause::"
msgstr ""

#: ../../reference/simple_stmts.rst:648
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information about handling exceptions is in "
"section :ref:`try`."
msgstr ""

#: ../../reference/simple_stmts.rst:651
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ""

#: ../../reference/simple_stmts.rst:654
msgid ""
"The ``__suppress_context__`` attribute to suppress automatic display of "
"the exception context."
msgstr ""

#: ../../reference/simple_stmts.rst:661
msgid "The :keyword:`!break` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:672
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class "
"definition within that loop."
msgstr ""

#: ../../reference/simple_stmts.rst:679
msgid ""
"It terminates the nearest enclosing loop, skipping the optional "
":keyword:`!else` clause if the loop has one."
msgstr ""

#: ../../reference/simple_stmts.rst:682
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop "
"control target keeps its current value."
msgstr ""

#: ../../reference/simple_stmts.rst:687
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really leaving the loop."
msgstr ""

#: ../../reference/simple_stmts.rst:695
msgid "The :keyword:`!continue` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:707
msgid ""
":keyword:`continue` may only occur syntactically nested in a "
":keyword:`for` or :keyword:`while` loop, but not nested in a function or "
"class definition within that loop.  It continues with the next cycle of "
"the nearest enclosing loop."
msgstr ""

#: ../../reference/simple_stmts.rst:711
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement"
" with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""

#: ../../reference/simple_stmts.rst:720
msgid "The :keyword:`!import` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:741
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two"
" steps:"
msgstr ""

#: ../../reference/simple_stmts.rst:744
msgid "find a module, loading and initializing it if necessary"
msgstr ""

#: ../../reference/simple_stmts.rst:745
msgid ""
"define a name or names in the local namespace for the scope where the "
":keyword:`import` statement occurs."
msgstr ""

#: ../../reference/simple_stmts.rst:748
msgid ""
"When the statement contains multiple clauses (separated by commas) the "
"two steps are carried out separately for each clause, just as though the "
"clauses had been separated out into individual import statements."
msgstr ""

#: ../../reference/simple_stmts.rst:753
msgid ""
"The details of the first step, finding and loading modules are described "
"in greater detail in the section on the :ref:`import system "
"<importsystem>`, which also describes the various types of packages and "
"modules that can be imported, as well as all the hooks that can be used "
"to customize the import system. Note that failures in this step may "
"indicate either that the module could not be located, *or* that an error "
"occurred while initializing the module, which includes execution of the "
"module's code."
msgstr ""

#: ../../reference/simple_stmts.rst:761
msgid ""
"If the requested module is retrieved successfully, it will be made "
"available in the local namespace in one of three ways:"
msgstr ""

#: ../../reference/simple_stmts.rst:766
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following"
" :keyword:`!as` is bound directly to the imported module."
msgstr ""

#: ../../reference/simple_stmts.rst:768
msgid ""
"If no other name is specified, and the module being imported is a top "
"level module, the module's name is bound in the local namespace as a "
"reference to the imported module"
msgstr ""

#: ../../reference/simple_stmts.rst:771
msgid ""
"If the module being imported is *not* a top level module, then the name "
"of the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module "
"must be accessed using its full qualified name rather than directly"
msgstr ""

#: ../../reference/simple_stmts.rst:781
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr ""

#: ../../reference/simple_stmts.rst:783
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""

#: ../../reference/simple_stmts.rst:785
msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ""

#: ../../reference/simple_stmts.rst:787
msgid "check if the imported module has an attribute by that name"
msgstr ""

#: ../../reference/simple_stmts.rst:788
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""

#: ../../reference/simple_stmts.rst:790
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr ""

#: ../../reference/simple_stmts.rst:791
msgid ""
"otherwise, a reference to that value is stored in the local namespace, "
"using the name in the :keyword:`!as` clause if it is present, otherwise "
"using the attribute name"
msgstr ""

#: ../../reference/simple_stmts.rst:795
msgid "Examples::"
msgstr ""

#: ../../reference/simple_stmts.rst:805
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public "
"names defined in the module are bound in the local namespace for the "
"scope where the :keyword:`import` statement occurs."
msgstr ""

#: ../../reference/simple_stmts.rst:811
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must "
"be a sequence of strings which are names defined or imported by that "
"module.  The names given in ``__all__`` are all considered public and are"
" required to exist.  If ``__all__`` is not defined, the set of public "
"names includes all names found in the module's namespace which do not "
"begin with an underscore character (``'_'``).  ``__all__`` should contain"
" the entire public API. It is intended to avoid accidentally exporting "
"items that are not part of the API (such as library modules which were "
"imported and used within the module)."
msgstr ""

#: ../../reference/simple_stmts.rst:821
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""

#: ../../reference/simple_stmts.rst:828
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within"
" another package it is possible to make a relative import within the same"
" top package without having to mention the package name. By using leading"
" dots in the specified module or package after :keyword:`from` you can "
"specify how high to traverse up the current package hierarchy without "
"specifying exact names. One leading dot means the current package where "
"the module making the import exists. Two dots means up one package level."
" Three dots is up two levels, etc. So if you execute ``from . import "
"mod`` from a module in the ``pkg`` package then you will end up importing"
" ``pkg.mod``. If you execute ``from ..subpkg2 import mod`` from within "
"``pkg.subpkg1`` you will import ``pkg.subpkg2.mod``. The specification "
"for relative imports is contained in the :ref:`relativeimports` section."
msgstr ""

#: ../../reference/simple_stmts.rst:842
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""

#: ../../reference/simple_stmts.rst:846
msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, "
"``sys.path_hooks``."
msgstr ""

#: ../../reference/simple_stmts.rst:850
msgid "Future statements"
msgstr ""

#: ../../reference/simple_stmts.rst:856
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a "
"particular module should be compiled using syntax or semantics that will "
"be available in a specified future release of Python where the feature "
"becomes standard."
msgstr ""

#: ../../reference/simple_stmts.rst:860
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows "
"use of the new features on a per-module basis before the release in which"
" the feature becomes standard."
msgstr ""

#: ../../reference/simple_stmts.rst:872
msgid ""
"A future statement must appear near the top of the module.  The only "
"lines that can appear before a future statement are:"
msgstr ""

#: ../../reference/simple_stmts.rst:875
msgid "the module docstring (if any),"
msgstr ""

#: ../../reference/simple_stmts.rst:876
msgid "comments,"
msgstr ""

#: ../../reference/simple_stmts.rst:877
msgid "blank lines, and"
msgstr ""

#: ../../reference/simple_stmts.rst:878
msgid "other future statements."
msgstr ""

#: ../../reference/simple_stmts.rst:880
msgid ""
"The only feature that requires using the future statement is "
"``annotations`` (see :pep:`563`)."
msgstr ""

#: ../../reference/simple_stmts.rst:883
msgid ""
"All historical features enabled by the future statement are still "
"recognized by Python 3.  The list includes ``absolute_import``, "
"``division``, ``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are "
"all redundant because they are always enabled, and only kept for "
"backwards compatibility."
msgstr ""

#: ../../reference/simple_stmts.rst:890
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in "
"which case the compiler may need to parse the module differently.  Such "
"decisions cannot be pushed off until runtime."
msgstr ""

#: ../../reference/simple_stmts.rst:897
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a"
" feature not known to it."
msgstr ""

#: ../../reference/simple_stmts.rst:901
msgid ""
"The direct runtime semantics are the same as for any import statement: "
"there is a standard module :mod:`__future__`, described later, and it "
"will be imported in the usual way at the time the future statement is "
"executed."
msgstr ""

#: ../../reference/simple_stmts.rst:905
msgid ""
"The interesting runtime semantics depend on the specific feature enabled "
"by the future statement."
msgstr ""

#: ../../reference/simple_stmts.rst:908
msgid "Note that there is nothing special about the statement::"
msgstr ""

#: ../../reference/simple_stmts.rst:912
msgid ""
"That is not a future statement; it's an ordinary import statement with no"
" special semantics or syntax restrictions."
msgstr ""

#: ../../reference/simple_stmts.rst:915
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and "
":func:`compile` that occur in a module :mod:`M` containing a future "
"statement will, by default, use the new syntax or semantics associated "
"with the future statement.  This can be controlled by optional arguments "
"to :func:`compile` --- see the documentation of that function for "
"details."
msgstr ""

#: ../../reference/simple_stmts.rst:921
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute,"
" and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""

#: ../../reference/simple_stmts.rst:929
msgid ":pep:`236` - Back to the __future__"
msgstr ""

#: ../../reference/simple_stmts.rst:930
msgid "The original proposal for the __future__ mechanism."
msgstr ""

#: ../../reference/simple_stmts.rst:936
msgid "The :keyword:`!global` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:946
msgid ""
"The :keyword:`global` statement is a declaration which holds for the "
"entire current code block.  It means that the listed identifiers are to "
"be interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to"
" globals without being declared global."
msgstr ""

#: ../../reference/simple_stmts.rst:952
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the "
"same code block textually preceding that :keyword:`!global` statement."
msgstr ""

#: ../../reference/simple_stmts.rst:955
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as "
"formal parameters or in a :keyword:`for` loop control target, "
":keyword:`class` definition, function definition, :keyword:`import` "
"statement, or variable annotation."
msgstr ""

#: ../../reference/simple_stmts.rst:962
msgid ""
"The current implementation does not enforce some of these restrictions, "
"but programs should not abuse this freedom, as future implementations may"
" enforce them or silently change the meaning of the program."
msgstr ""

#: ../../reference/simple_stmts.rst:971
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  "
"It applies only to code parsed at the same time as the :keyword:`!global`"
" statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does"
" not affect the code block *containing* the function call, and code "
"contained in such a string is unaffected by :keyword:`!global` statements"
" in the code containing the function call.  The same applies to the "
":func:`eval` and :func:`compile` functions."
msgstr ""

#: ../../reference/simple_stmts.rst:983
msgid "The :keyword:`!nonlocal` statement"
msgstr ""

#: ../../reference/simple_stmts.rst:995
msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer "
"to previously bound variables in the nearest enclosing scope excluding "
"globals. This is important because the default behavior for binding is to"
" search the local namespace first.  The statement allows encapsulated "
"code to rebind variables outside of the local scope besides the global "
"(module) scope."
msgstr ""

#: ../../reference/simple_stmts.rst:1005
msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike those listed in a"
" :keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created "
"cannot be determined unambiguously)."
msgstr ""

#: ../../reference/simple_stmts.rst:1010
msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with "
"pre-existing bindings in the local scope."
msgstr ""

#: ../../reference/simple_stmts.rst:1015
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ""

#: ../../reference/simple_stmts.rst:1016
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr ""

#: ../../reference/toplevel_components.rst:6
msgid "Top-level components"
msgstr ""

#: ../../reference/toplevel_components.rst:10
msgid ""
"The Python interpreter can get its input from a number of sources: from a"
" script passed to it as standard input or as program argument, typed in "
"interactively, from a module source file, etc.  This chapter gives the "
"syntax used in these cases."
msgstr ""

#: ../../reference/toplevel_components.rst:19
msgid "Complete Python programs"
msgstr ""

#: ../../reference/toplevel_components.rst:28
msgid ""
"While a language specification need not prescribe how the language "
"interpreter is invoked, it is useful to have a notion of a complete "
"Python program.  A complete Python program is executed in a minimally "
"initialized environment: all built-in and standard modules are available,"
" but none have been initialized, except for :mod:`sys` (various system "
"services), :mod:`builtins` (built-in functions, exceptions and ``None``) "
"and :mod:`__main__`.  The latter is used to provide the local and global "
"namespace for execution of the complete program."
msgstr ""

#: ../../reference/toplevel_components.rst:36
msgid ""
"The syntax for a complete Python program is that for file input, "
"described in the next section."
msgstr ""

#: ../../reference/toplevel_components.rst:43
msgid ""
"The interpreter may also be invoked in interactive mode; in this case, it"
" does not read and execute a complete program but reads and executes one "
"statement (possibly compound) at a time.  The initial environment is "
"identical to that of a complete program; each statement is executed in "
"the namespace of :mod:`__main__`."
msgstr ""

#: ../../reference/toplevel_components.rst:55
msgid ""
"A complete program can be passed to the interpreter in three forms: with "
"the :option:`-c` *string* command line option, as a file passed as the "
"first command line argument, or as standard input.  If the file or "
"standard input is a tty device, the interpreter enters interactive mode; "
"otherwise, it executes the file as a complete program."
msgstr ""

#: ../../reference/toplevel_components.rst:65
msgid "File input"
msgstr ""

#: ../../reference/toplevel_components.rst:67
msgid "All input read from non-interactive files has the same form:"
msgstr ""

#: ../../reference/toplevel_components.rst:72
msgid "This syntax is used in the following situations:"
msgstr ""

#: ../../reference/toplevel_components.rst:74
msgid "when parsing a complete Python program (from a file or from a string);"
msgstr ""

#: ../../reference/toplevel_components.rst:76
msgid "when parsing a module;"
msgstr ""

#: ../../reference/toplevel_components.rst:78
msgid "when parsing a string passed to the :func:`exec` function;"
msgstr ""

#: ../../reference/toplevel_components.rst:84
msgid "Interactive input"
msgstr ""

#: ../../reference/toplevel_components.rst:86
msgid "Input in interactive mode is parsed using the following grammar:"
msgstr ""

#: ../../reference/toplevel_components.rst:91
msgid ""
"Note that a (top-level) compound statement must be followed by a blank "
"line in interactive mode; this is needed to help the parser detect the "
"end of the input."
msgstr ""

#: ../../reference/toplevel_components.rst:98
msgid "Expression input"
msgstr ""

#: ../../reference/toplevel_components.rst:103
msgid ""
":func:`eval` is used for expression input.  It ignores leading "
"whitespace. The string argument to :func:`eval` must have the following "
"form:"
msgstr ""

